"""API Wrapper Tools for Zoom

DO NOT EDIT THIS MODULE DIRECTLY.

THIS MODULE WAS AUTO-GENERATED BY TRANSPILING THE API WRAPPER TOOL JSON DEFINITIONS
IN THE ../wrapper_tools DIRECTORY INTO PYTHON CODE. ANY CHANGES TO THIS MODULE WILL
BE OVERWRITTEN BY THE TRANSPILER.
"""

from typing import Annotated, Any

import httpx
from arcade_tdk import ToolContext, tool
from arcade_tdk.auth import OAuth2


def remove_none_values(data: dict[str, Any]) -> dict[str, Any]:
    return {k: v for k, v in data.items() if v is not None}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "recording:read:admin",
            "archiving:read:list_archived_files:admin",
            "archiving:read:list_archived_files:master",
        ],
    )
)
async def get_archived_zoom_files(
    context: ToolContext,
    number_of_records_per_call: Annotated[
        int | None,
        "Specify the number of records to retrieve in a single API call. Use an integer value.",
    ] = None,
    pagination_token: Annotated[
        str | None,
        "Token used to fetch the next set of results when result exceeds current page size. Expires in 15 minutes.",  # noqa: E501
    ] = None,
    query_start_date: Annotated[
        str | None,
        "The starting date for the query in `yyyy-MM-dd'T'HH:mm:ssZ` format. Must not exceed seven days from the `query_end_date`.",  # noqa: E501
    ] = None,
    query_end_date: Annotated[
        str | None,
        "The end date for the query in `yyyy-MM-dd'T'HH:mm:ssZ` format, not exceeding seven days from the start date.",  # noqa: E501
    ] = None,
    query_date_type: Annotated[
        str | None,
        "Specifies the type of date to query: 'meeting_start_time' or 'archive_complete_time'. Defaults to 'meeting_start_time'.",  # noqa: E501
    ] = None,
    deprecated_group_id: Annotated[
        str | None,
        "This argument is deprecated. Please use 'group_ids' instead for querying Zoom group information.",  # noqa: E501
    ] = None,
    filter_by_group_ids: Annotated[
        str | None,
        "Comma-separated list of group IDs to filter archived files. Maximum 7 group IDs.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listArchivedFiles'."]:
    """Retrieve a Zoom account's archived meeting or webinar files.

    Use this tool to access archived meeting or webinar files for a Zoom account. Ensure that the Meeting and Webinar Archiving feature is enabled by Zoom Support. Requires appropriate admin scopes: `recording:read:admin`, `archiving:read:list_archived_files:admin`, or `archiving:read:list_archived_files:master`."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/archive_files",
            params=remove_none_values({
                "page_size": number_of_records_per_call,
                "next_page_token": pagination_token,
                "from": query_start_date,
                "to": query_end_date,
                "query_date_type": query_date_type,
                "group_id": deprecated_group_id,
                "group_ids": filter_by_group_ids,
            }),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=["recording:read:admin", "archiving:read:archived_file_statistics:admin"],
    )
)
async def get_archived_file_statistics(
    context: ToolContext,
    query_start_date: Annotated[
        str | None,
        "The start date for querying archived files, formatted as `yyyy-MM-dd'T'HH:mm:ssZ`. Must be within seven days of `query_end_date`.",  # noqa: E501
    ] = None,
    query_end_date: Annotated[
        str | None,
        "The query end date for retrieving statistics, in `yyyy-MM-dd'T'HH:mm:ssZ` format. Ensure the duration between this and the start date does not exceed seven days.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getArchivedFileStatistics'."]:
    """Retrieve statistics about archived Zoom meeting files.

    Use this tool to obtain statistics regarding archived meeting or webinar files for a Zoom account. This is useful for compliance purposes, such as FINRA requirements. Prerequisites include enabling the Meeting and Webinar Archiving feature and appropriate admin scopes."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/archive_files/statistics",
            params=remove_none_values({"from": query_start_date, "to": query_end_date}),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "archiving:read:archived_files:admin",
            "archiving:read:archived_files",
            "recording:read",
        ],
    )
)
async def get_zoom_archived_files(
    context: ToolContext,
    meeting_uuid: Annotated[
        str,
        "The universally unique identifier (UUID) of the Zoom meeting. Double encode if it starts with '/' or contains '//' when making other API calls.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getArchivedFiles'."]:
    """Retrieve archived files from a specific Zoom meeting.

    Fetches archived files from a specified Zoom meeting instance. This tool is useful when you need details of past meeting records and files, given that the Meeting and Webinar Archiving feature is enabled in your account."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/past_meetings/{meetingUUID}/archive_files".format(  # noqa: UP032
                meetingUUID=meeting_uuid
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom", scopes=["archiving:delete:archived_files:admin", "recording:write:admin"]
    )
)
async def delete_meeting_archived_files(
    context: ToolContext,
    meeting_uuid: Annotated[
        str,
        "The universally unique identifier (UUID) of the meeting. Ensure double-encoding if the UUID begins with a '/' or contains '//'.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteArchivedFiles'."]:
    """Deletes all archived files of a specified meeting.

    This tool is used to delete all archived files from a specific meeting in Zoom. It requires the 'Meeting and Webinar Archiving' feature to be enabled and appropriate permissions set. This should be called when there's a need to remove archived meeting data."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/past_meetings/{meetingUUID}/archive_files".format(  # noqa: UP032
                meetingUUID=meeting_uuid
            ),
            method="DELETE",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "cloud_recording:read:list_recording_files:admin",
            "phone_recording:read:admin",
            "recording:read",
            "cloud_recording:read:list_recording_files",
            "cloud_recording:read:list_recording_files:master",
        ],
    )
)
async def get_meeting_recordings(
    context: ToolContext,
    meeting_id_or_uuid: Annotated[
        str,
        "Provide the Zoom meeting ID or UUID to retrieve cloud recordings. If using UUID, double encode if needed.",  # noqa: E501
    ],
    include_download_access_token: Annotated[
        str | None,
        "Set to 'download_access_token' to include this field in the response for downloading recordings. Requires 'View the recording content' permission.",  # noqa: E501
    ] = None,
    download_access_token_ttl: Annotated[
        int | None,
        "The Time to Live value for the download access token. Only valid if `include_fields` includes `download_access_token`.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'recordingGet'."]:
    """Retrieve all recordings for a specified Zoom meeting.

    Use this tool to get all recordings associated with a Zoom meeting. It provides information necessary to download the recordings, including handling password-protected files with access tokens."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/meetings/{meetingId}/recordings".format(  # noqa: UP032
                meetingId=meeting_id_or_uuid
            ),
            params=remove_none_values({
                "include_fields": include_download_access_token,
                "ttl": download_access_token_ttl,
            }),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "recording:write:admin",
            "cloud_recording:delete:meeting_recording",
            "cloud_recording:delete:meeting_recording:master",
            "cloud_recording:delete:meeting_recording:admin",
            "recording:write",
        ],
    )
)
async def delete_zoom_recordings(
    context: ToolContext,
    meeting_or_webinar_identifier: Annotated[
        str,
        "Provide the meeting or webinar ID/UUID to delete its cloud recordings. If using a UUID starting with '/' or containing '//', double encode it.",  # noqa: E501
    ],
    recording_delete_action: Annotated[
        str | None,
        "Specify the action for deleting recordings: `trash` to move to trash or `delete` for permanent removal.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'recordingDelete'."]:
    """Delete a meeting or webinar's cloud recordings.

    Use this tool to delete all cloud recordings of a specified Zoom meeting or webinar. Ensure that Cloud Recording is enabled on the user's account. Appropriate scopes are needed for this operation."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/meetings/{meetingId}/recordings".format(  # noqa: UP032
                meetingId=meeting_or_webinar_identifier
            ),
            params=remove_none_values({"action": recording_delete_action}),
            method="DELETE",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "cloud_recording:read:recording_analytics_details",
            "cloud_recording:read:recording_analytics_details:master",
            "cloud_recording:read:recording_analytics_details:admin",
        ],
    )
)
async def get_zoom_recording_analytics(
    context: ToolContext,
    meeting_or_webinar_id: Annotated[
        str,
        "Provide the meeting or webinar ID/UUID to retrieve cloud recordings. Double encode UUIDs starting with '/' or containing '//'.",  # noqa: E501
    ],
    records_per_page: Annotated[
        int | None,
        "The number of analytics records to return in one API call. Adjust for batch size.",
    ] = None,
    pagination_token: Annotated[
        str | None,
        "A token for navigating through pages of large result sets. It expires 15 minutes after retrieval.",  # noqa: E501
    ] = None,
    start_date: Annotated[
        str | None,
        "The start date for the monthly range to query, formatted as YYYY-MM-DD. Defaults to current date if not provided.",  # noqa: E501
    ] = None,
    end_date: Annotated[
        str | None,
        "The end date for the queried monthly range. Format: YYYY-MM-DD. The duration can't exceed one month from the start date.",  # noqa: E501
    ] = None,
    analytics_detail_type: Annotated[
        str | None,
        "Specify the type of analytics details to retrieve: 'by_view' for view-based details or 'by_download' for download-based details.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'analytics_details'."]:
    """Retrieve analytics details for Zoom meeting or webinar recordings.

    Use this tool to obtain detailed analytics for a Zoom meeting or webinar recording, covering data up to one month. Requires appropriate permissions."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/meetings/{meetingId}/recordings/analytics_details".format(  # noqa: UP032
                meetingId=meeting_or_webinar_id
            ),
            params=remove_none_values({
                "page_size": records_per_page,
                "next_page_token": pagination_token,
                "from": start_date,
                "to": end_date,
                "type": analytics_detail_type,
            }),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "cloud_recording:read:recording_analytics_summary:admin",
            "cloud_recording:read:recording_analytics_summary",
            "cloud_recording:read:recording_analytics_summary:master",
        ],
    )
)
async def get_meeting_analytics_summary(
    context: ToolContext,
    meeting_id_or_uuid: Annotated[
        str,
        "Provide the meeting or webinar ID/UUID to retrieve cloud recordings. Double encode UUIDs with special characters.",  # noqa: E501
    ],
    start_date: Annotated[
        str | None,
        "The start date for the monthly range to query, in YYYY-MM-DD format. Defaults to the current date if not provided.",  # noqa: E501
    ] = None,
    end_date_for_query: Annotated[
        str | None,
        "The end date for the monthly range to query. Format as YYYY-MM-DD. The range must not exceed one month.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'analytics_summary'."]:
    """Retrieve analytics summary of a Zoom meeting recording.

    Use this tool to retrieve the analytics summary of a Zoom meeting recording, valid for up to one month. Ensure appropriate access scopes are set for reading recording analytics summaries."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/meetings/{meetingId}/recordings/analytics_summary".format(  # noqa: UP032
                meetingId=meeting_id_or_uuid
            ),
            params=remove_none_values({"from": start_date, "to": end_date_for_query}),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "cloud_recording:read:list_recording_registrants:admin",
            "cloud_recording:read:list_recording_registrants",
            "recording:read",
            "cloud_recording:read:list_recording_registrants:master",
            "recording:read:admin",
        ],
    )
)
async def get_meeting_recording_registrants(
    context: ToolContext,
    meeting_id: Annotated[
        int,
        "The meeting's ID, which can exceed 10 digits. Store as a long format integer to ensure compatibility.",  # noqa: E501
    ],
    registrant_status_filter: Annotated[
        str | None, "Filter registrants by status: 'pending', 'approved', or 'denied'."
    ] = None,
    records_per_page: Annotated[
        int | None, "Specify the number of registrant records to retrieve per API call."
    ] = None,
    use_next_page_token: Annotated[
        int | None,
        "Indicate whether to use `next_page_token` for pagination instead of `page_number`.",
    ] = None,
    pagination_token: Annotated[
        str | None, "Token for paginating through large result sets. Expires in 15 minutes."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'meetingRecordingRegistrants'."]:
    """Fetch registrants of past meeting recordings on Zoom.

    Use this tool to get a list of people who registered to view the on-demand recordings of a past Zoom meeting. This is helpful to monitor who has accessed specific recorded content."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/meetings/{meetingId}/recordings/registrants".format(  # noqa: UP032
                meetingId=meeting_id
            ),
            params=remove_none_values({
                "status": registrant_status_filter,
                "page_size": records_per_page,
                "page_number": use_next_page_token,
                "next_page_token": pagination_token,
            }),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "recording:read",
            "cloud_recording:read:registration_questions",
            "cloud_recording:read:registration_questions:master",
            "recording:read:admin",
            "cloud_recording:read:registration_questions:admin",
        ],
    )
)
async def get_recording_registration_questions(
    context: ToolContext,
    meeting_or_webinar_id: Annotated[
        str,
        "Provide the meeting or webinar ID/UUID to get the cloud recordings. Double encode UUIDs starting with '/' or containing '//'.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'recordingRegistrantsQuestionsGet'."
]:
    """Retrieve questions for registering to view a Zoom meeting recording.

    Use this tool to get the list of questions displayed to users registering to view the recording of a specific Zoom meeting. This is useful for on-demand meeting recordings where questions are part of the registration process. Requires appropriate recording read permissions."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/meetings/{meetingId}/recordings/registrants/questions".format(  # noqa: UP032
                meetingId=meeting_or_webinar_id
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "recording:read",
            "cloud_recording:read:recording_settings:master",
            "cloud_recording:read:recording_settings",
            "cloud_recording:read:recording_settings:admin",
            "recording:read:admin",
        ],
    )
)
async def get_zoom_meeting_recording_settings(
    context: ToolContext,
    zoom_meeting_id: Annotated[
        str,
        "The ID or UUID of the meeting/webinar for retrieving cloud recordings. Double encode UUIDs starting with '/' or containing '//'.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'recordingSettingUpdate'."]:
    """Retrieve a Zoom meeting's cloud recording settings and access info.

    Use this tool to access the cloud recording settings for a specific Zoom meeting. It provides information on recording content access, requiring the 'View the recording content' permission. Useful for managing and reviewing meeting recording configurations."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/meetings/{meetingId}/recordings/settings".format(  # noqa: UP032
                meetingId=zoom_meeting_id
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "recording:write:admin",
            "cloud_recording:delete:recording_file",
            "recording:write",
            "cloud_recording:delete:recording_file:master",
            "cloud_recording:delete:recording_file:admin",
        ],
    )
)
async def delete_zoom_recording(
    context: ToolContext,
    meeting_or_webinar_id: Annotated[
        str,
        "Provide the meeting ID or UUID, or the webinar ID or UUID to access cloud recordings. UUIDs with `/` or `//` require double encoding.",  # noqa: E501
    ],
    recording_id: Annotated[str, "The unique identifier for the recording you wish to delete."],
    recording_delete_action: Annotated[
        str | None,
        "Specify the action for recording deletion. Use 'trash' to move it to trash or 'delete' to remove permanently.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'recordingDeleteOne'."]:
    """Delete a specific Zoom recording from a meeting or webinar.

    Use this tool to delete a specific recording file from a Zoom meeting or webinar. Ensure the setting for allowing the host to delete cloud recordings is enabled in Zoom. This tool requires appropriate recording deletion permissions."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/meetings/{meetingId}/recordings/{recordingId}".format(  # noqa: UP032
                meetingId=meeting_or_webinar_id, recordingId=recording_id
            ),
            params=remove_none_values({"action": recording_delete_action}),
            method="DELETE",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "recording:write:admin",
            "cloud_recording:read:meeting_transcript",
            "recording:read",
            "recording:read:admin",
            "cloud_recording:read:meeting_transcript:admin",
            "recording:write",
        ],
    )
)
async def get_meeting_transcript(
    context: ToolContext,
    meeting_id_or_uuid: Annotated[
        str,
        "Provide the meeting or webinar ID/UUID to retrieve its transcript. Double encode UUIDs starting with '/' or containing '//' before requesting.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'GetMeetingTranscript'."]:
    """Retrieve a Zoom meeting's transcript information.

    Use this tool to obtain the transcript information for a specified Zoom meeting. The response includes a download URL to access the full transcript content. Ensure user's OAuth access token is included in the authorization header when accessing the download URL."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/meetings/{meetingId}/transcript".format(  # noqa: UP032
                meetingId=meeting_id_or_uuid
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "recording:write",
            "cloud_recording:delete:meeting_transcript:admin",
            "recording:write:admin",
            "cloud_recording:delete:meeting_transcript",
        ],
    )
)
async def delete_zoom_meeting_transcript(
    context: ToolContext,
    meeting_or_webinar_identifier: Annotated[
        str,
        "Provide the meeting ID or its unique universal identifier (UUID) to delete the transcript. For webinars, use the webinar ID or UUID. Ensure double encoding if the UUID starts with '/' or contains '//'.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'DeleteMeetingTranscript'."]:
    """Delete a transcript for a Zoom meeting or webinar.

    Use this tool to delete a transcript associated with a specific Zoom meeting or webinar. This action requires appropriate OAuth scopes for authorization."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/meetings/{meetingId}/transcript".format(  # noqa: UP032
                meetingId=meeting_or_webinar_identifier
            ),
            method="DELETE",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "cloud_recording:read:list_user_recordings:master",
            "cloud_recording:read:list_user_recordings:admin",
            "recording:read",
            "cloud_recording:read:list_user_recordings",
            "recording:read:admin",
        ],
    )
)
async def list_zoom_cloud_recordings(
    context: ToolContext,
    user_identifier: Annotated[
        str, "The user's ID, email address, or 'me' for the current user context."
    ],
    records_per_page: Annotated[
        int | None,
        "Specify the number of recordings to return in a single call. Adjust to limit response size.",  # noqa: E501
    ] = None,
    pagination_next_page_token: Annotated[
        str | None,
        "A token to paginate through large sets of results. It expires after 15 minutes.",
    ] = None,
    meeting_connector_metadata: Annotated[
        str | None, "Metadata for recordings using an on-premise meeting connector."
    ] = None,
    start_date: Annotated[
        str | None,
        "The start date in 'yyyy-mm-dd' UTC format for retrieving recordings. Must be within a month range. Defaults to current date if not specified. Note: Not applicable for trash files.",  # noqa: E501
    ] = None,
    end_date_utc: Annotated[
        str | None, "The end date for retrieving recordings, in 'yyyy-mm-dd' UTC format."
    ] = None,
    cloud_recording_trash_type: Annotated[
        str | None,
        "Specify the type of cloud recording to retrieve from trash: 'meeting_recordings' for meeting recordings, 'recording_file' for individual files.",  # noqa: E501
    ] = None,
    meeting_id: Annotated[
        int | None,
        "The unique identifier for the Zoom meeting. Provide this to filter recordings by a specific meeting.",  # noqa: E501
    ] = None,
    include_trash_recordings: Annotated[
        bool | None,
        "Set to true to include recordings from the trash. Defaults to false. Use trash_type for specific types.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'recordingsList'."]:
    """Retrieve a user's Zoom cloud recordings.

    This tool retrieves all cloud recordings for a specified Zoom user. It requires a Pro plan or higher and cloud recording must be enabled on the user's account. Use the tool to list recordings by providing the user ID or 'me' for current user context. Access to passcode-protected recordings requires an OAuth access token."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/users/{userId}/recordings".format(userId=user_identifier),  # noqa: UP032
            params=remove_none_values({
                "page_size": records_per_page,
                "next_page_token": pagination_next_page_token,
                "mc": meeting_connector_metadata,
                "trash": include_trash_recordings,
                "from": start_date,
                "to": end_date_utc,
                "trash_type": cloud_recording_trash_type,
                "meeting_id": meeting_id,
            }),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-zoom", scopes=["device:write:admin", "device:read:admin"]))
async def list_zoom_devices(
    context: ToolContext,
    filter_by_name_or_serial_number: Annotated[
        str | None,
        "Filter devices by providing a name or serial number to narrow the search results.",
    ] = None,
    filter_by_platform_os: Annotated[
        str | None,
        "Filter devices by platform operating system. Options: 'win', 'mac', 'ipad', 'iphone', 'android', 'linux'.",  # noqa: E501
    ] = None,
    filter_by_device_type: Annotated[
        int | None,
        "Specify the integer code to filter devices by their type. The options are: `-1` for all Zoom Room devices, `0` for Zoom Rooms Computer, `1` for Zoom Rooms Controller, `2` for Zoom Rooms Scheduling Display, `3` for Zoom Rooms Control System, `4` for Zoom Rooms Whiteboard, `5` for Zoom Phone Appliance, and `6` for Zoom Rooms Computer (with Controller).",  # noqa: E501
    ] = None,
    filter_by_device_vendor: Annotated[
        str | None, "Specify the vendor to filter devices by their manufacturer or brand."
    ] = None,
    filter_device_by_model: Annotated[
        str | None,
        "Filter results to include only devices matching a specific model. Provide the model name as a string.",  # noqa: E501
    ] = None,
    device_status_filter: Annotated[
        int | None,
        "Filter devices by their status: `0` for offline, `1` for online, `-1` for unlinked.",
    ] = None,
    result_limit: Annotated[
        int | None,
        "Specify the maximum number of records to return in a single call, controlling the data volume retrieved.",  # noqa: E501
    ] = None,
    pagination_token: Annotated[
        str | None,
        "Token for retrieving the next page of device results. It expires after 15 minutes.",
    ] = None,
    filter_by_zdm_enrollment: Annotated[
        bool | None,
        "Filter devices by their enrollment in Zoom Device Management (ZDM). Use true for enrolled and false for not enrolled.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listDevices'."]:
    """Retrieve a list of devices from Zoom.

    Use this tool to obtain a list of all devices associated with a Zoom account. This can help in managing or auditing device usage within an organization."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/devices",
            params=remove_none_values({
                "search_text": filter_by_name_or_serial_number,
                "platform_os": filter_by_platform_os,
                "is_enrolled_in_zdm": filter_by_zdm_enrollment,
                "device_type": filter_by_device_type,
                "device_vendor": filter_by_device_vendor,
                "device_model": filter_device_by_model,
                "device_status": device_status_filter,
                "page_size": result_limit,
                "next_page_token": pagination_token,
            }),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "device:read:list_groups:master",
            "device:read:admin",
            "device:read:list_groups:admin",
        ],
    )
)
async def get_zoom_device_manager_group_info(
    context: ToolContext,
    records_per_page: Annotated[
        int | None,
        "The total number of records to return per API call. Default is 30, with a maximum of 100.",
    ] = None,
    pagination_next_page_token: Annotated[
        str | None,
        "Token to retrieve the next set of results for paginated Zoom Device Manager group data. Valid for 15 minutes.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'Getzdmgroupinfo'."]:
    """Retrieve Zoom Device Manager group information for an account.

    Use this tool to obtain detailed information about Zoom Device Manager groups associated with an account. Useful for administrators needing insight into device group configurations."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/devices/groups",
            params=remove_none_values({
                "page_size": records_per_page,
                "next_page_token": pagination_next_page_token,
            }),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "device:read:user_setting:admin",
            "device:read:admin",
            "device:read:user_setting:master",
        ],
    )
)
async def get_zoom_phone_device_settings(
    context: ToolContext,
    user_identifier: Annotated[
        str | None,
        "The Zoom user's ID or email address. Use 'me' for user-level apps to represent the current user.",  # noqa: E501
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'GetZpaDeviceListProfileSettingOfaUser'."
]:
    """Retrieve user's Zoom Phone Appliance device settings.

    Use this tool to get the device profile settings for a user's Zoom Phone Appliance. Suitable for user-level apps by passing 'me' for userId. Requires appropriate OAuth scopes. Medium rate limit applies."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/devices/zpa/settings",
            params=remove_none_values({"user_id": user_identifier}),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "device:write:admin",
            "device:delete:zpa_device:admin",
            "device:delete:zpa_device:master",
        ],
    )
)
async def remove_zoom_device_by_vendor_and_mac(
    context: ToolContext,
    device_vendor: Annotated[
        str, "The manufacturer's name of the device to be removed from Zoom's device manager."
    ],
    device_mac_address: Annotated[
        str,
        "The MAC address of the device to be removed. This identifier is a string and is required for the operation.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'DeleteZpaDeviceByVendorAndMacAddress'."
]:
    """Remove a ZPA device from Zoom by vendor and MAC address.

    Use this tool to remove a ZPA device from the Zoom device manager by specifying the vendor and MAC address of the device. Applicable for scenarios where device deauthorization is needed."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/devices/zpa/vendors/{vendor}/mac_addresses/{macAddress}".format(  # noqa: UP032
                vendor=device_vendor, macAddress=device_mac_address
            ),
            method="DELETE",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "device:read:list_zpa_versions:admin",
            "device:read:list_zpa_versions:master",
            "device:read:admin",
        ],
    )
)
async def get_zoom_zpa_version_info(
    context: ToolContext,
    zoom_device_management_group_id: Annotated[
        str,
        "The ID of the Zoom Device Management (ZDM) group for which you want to retrieve ZPA firmware and app version info.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'GetZpaVersioninfo'."]:
    """Retrieve ZPA firmware and app versions for Zoom devices.

    This tool fetches the list of ZPA firmware and app version information that can be upgraded for Zoom devices within a specified ZDM group. It should be used to check available upgrades and ensures the use of the appropriate OAuth scopes."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/devices/zpa/zdm_groups/{zdmGroupId}/versions".format(  # noqa: UP032
                zdmGroupId=zoom_device_management_group_id
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-zoom", scopes=["device:write:admin", "device:read:admin"]))
async def retrieve_zoom_device_details(
    context: ToolContext,
    device_unique_identifier: Annotated[
        str, "The unique identifier of the Zoom device to retrieve details for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getDevice'."]:
    """Retrieve a Zoom device's details.

    Use this tool to fetch detailed information about a specific device registered in Zoom. Useful for administrators managing Zoom devices."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/devices/{deviceId}".format(  # noqa: UP032
                deviceId=device_unique_identifier
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-zoom", scopes=["device:write:admin"]))
async def remove_zoom_device(
    context: ToolContext,
    device_id: Annotated[
        str,
        "The unique identifier of the device to be removed from the Zoom account. Ensure the device is enrolled in Zoom Device Management (ZMD) before calling.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteDevice'."]:
    """Removes a device from a Zoom account via ZMD.

    This tool deletes a device from a Zoom account. It should be called when a device enrolled in Zoom Device Management (ZMD) needs to be removed. Requires the `device:write:admin` scope. Subject to HEAVY rate limits."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/devices/{deviceId}".format(deviceId=device_id),  # noqa: UP032
            method="DELETE",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=["device:write:admin", "device:write:group:master", "device:write:group:admin"],
    )
)
async def assign_zoom_device_to_group(
    context: ToolContext,
    zoom_group_id: Annotated[
        str, "The unique identifier for the Zoom group to which the device will be assigned."
    ],
    zoom_device_id: Annotated[
        str, "The unique identifier for the Zoom device to be assigned to a group."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'assginGroup'."]:
    """Assign a Zoom device to a specified group.

    Use this tool to assign a Zoom device to a specific group. It is useful for managing device organization in Zoom. The tool requires the appropriate OAuth scopes to function and adheres to Zoom's rate limits."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/devices/{deviceId}/assign_group".format(  # noqa: UP032
                deviceId=zoom_device_id
            ),
            params=remove_none_values({"group_id": zoom_group_id}),
            method="PATCH",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom", scopes=["h323:read:admin", "h323_device:read:list_devices:admin"]
    )
)
async def list_zoom_h323_sip_devices(
    context: ToolContext,
    records_per_call: Annotated[
        int | None,
        "The number of records to return in a single API call when listing H.323/SIP devices. Adjust to manage response size.",  # noqa: E501
    ] = None,
    use_page_number: Annotated[
        int | None,
        "**Deprecated.** Indicates if the `page_number` should be used for pagination. Use `next_page_token` instead.",  # noqa: E501
    ] = None,
    pagination_token: Annotated[
        str | None, "Token for paginating large result sets. Expires after 15 minutes."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deviceList'."]:
    """Retrieve all H.323/SIP devices on a Zoom account.

    Use this tool to get a list of all H.323/SIP devices configured in a Zoom account. Ideal for managing or auditing video conferencing infrastructure using Zoom's Room Connector feature."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/h323/devices",
            params=remove_none_values({
                "page_size": records_per_call,
                "page_number": use_page_number,
                "next_page_token": pagination_token,
            }),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom", scopes=["h323:write:admin", "h323_device:delete:device:admin"]
    )
)
async def delete_zoom_device(
    context: ToolContext,
    device_id_to_delete: Annotated[
        str, "The unique identifier of the H.323 or SIP device to be deleted from the Zoom account."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deviceDelete'."]:
    """Delete a H.323 or SIP device from your Zoom account.

    Use this tool to delete a H.323 or SIP device associated with your Zoom account, enabling more precise management of video call devices."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/h323/devices/{deviceId}".format(  # noqa: UP032
                deviceId=device_id_to_delete
            ),
            method="DELETE",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "meeting:delete:live_meeting_chat_message",
            "meeting:delete:live_meeting_chat_message:admin",
            "meeting:write:admin",
            "meeting:write",
        ],
    )
)
async def delete_zoom_meeting_chat_message(
    context: ToolContext,
    zoom_meeting_id: Annotated[
        int,
        "The unique identifier for the meeting. Store this value as a long-format integer since it can exceed 10 digits.",  # noqa: E501
    ],
    chat_message_uuid_base64: Annotated[
        str, "The unique identifier for the live meeting chat message, encoded in base64 format."
    ],
    chat_file_ids_base64: Annotated[
        str | None,
        "Base64-encoded IDs of live webinar chat files. Separate multiple values with commas.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteMeetingChatMessageById'."]:
    """Delete a live Zoom meeting chat message by ID.

    Use this tool to delete a specific message in a live Zoom meeting. Ensure Zoom's DLP for in-meeting chats is enabled. Relevant scopes are required for authorization."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/live_meetings/{meetingId}/chat/messages/{messageId}".format(  # noqa: UP032
                meetingId=zoom_meeting_id, messageId=chat_message_uuid_base64
            ),
            params=remove_none_values({"file_ids": chat_file_ids_base64}),
            method="DELETE",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom", scopes=["meeting:read:list_summaries:admin", "meeting_summary:read:admin"]
    )
)
async def list_meeting_summaries(
    context: ToolContext,
    number_of_records_per_call: Annotated[
        int | None,
        "Specify the number of summaries to return in one API call. This controls the page size.",
    ] = None,
    pagination_next_page_token: Annotated[
        str | None, "Token to paginate through large result sets. Expires in 15 minutes."
    ] = None,
    start_date_utc: Annotated[
        str | None,
        "The start date in UTC format (`yyyy-MM-dd'T'HH:mm:ss'Z'`) to filter meeting summaries by creation date.",  # noqa: E501
    ] = None,
    end_date_utc: Annotated[
        str | None,
        "The end date in `yyyy-MM-dd'T'HH:mm:ss'Z'` UTC format to retrieve meeting summaries within this date range.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'Listmeetingsummaries'."]:
    """Retrieve meeting and webinar summaries for an account.

    Use this tool to get a list of all meeting or webinar summaries available for a Zoom account. This requires the host to have an appropriate subscription and settings enabled. Note: End-to-End Encrypted meetings do not support summaries."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/meetings/meeting_summaries",
            params=remove_none_values({
                "page_size": number_of_records_per_call,
                "next_page_token": pagination_next_page_token,
                "from": start_date_utc,
                "to": end_date_utc,
            }),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "meeting:read:meeting:admin",
            "meeting:read",
            "meeting:read:admin",
            "meeting:read:meeting",
        ],
    )
)
async def get_zoom_meeting_details(
    context: ToolContext,
    zoom_meeting_id: Annotated[
        int,
        "The unique ID of the Zoom meeting. Ensure it is stored as a long format integer due to potential lengths over 10 digits.",  # noqa: E501
    ],
    meeting_occurrence_id: Annotated[
        str | None,
        "The ID of a specific occurrence of a recurring Zoom meeting. This is needed to retrieve details for that particular occurrence.",  # noqa: E501
    ] = None,
    show_previous_occurrences: Annotated[
        bool | None,
        "Set to true to view details of all previous occurrences of a recurring meeting.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'meeting'."]:
    """Retrieve details of a specified Zoom meeting.

    Call this tool to get information about a specific Zoom meeting, such as its host and scheduled times. Ensure the host has a Zoom Meetings Basic license or higher."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/meetings/{meetingId}".format(meetingId=zoom_meeting_id),  # noqa: UP032
            params=remove_none_values({
                "occurrence_id": meeting_occurrence_id,
                "show_previous_occurrences": show_previous_occurrences,
            }),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "meeting:write:admin",
            "meeting:delete:meeting:admin",
            "meeting:delete:meeting",
            "meeting:write",
        ],
    )
)
async def delete_zoom_meeting(
    context: ToolContext,
    meeting_id: Annotated[
        int,
        "The unique identifier for the Zoom meeting. Ensure to handle as a long integer due to potential size exceeding 10 digits.",  # noqa: E501
    ],
    meeting_occurrence_id: Annotated[
        str | None,
        "The ID for a specific meeting or webinar occurrence. Necessary for deleting a single occurrence in a recurring series.",  # noqa: E501
    ] = None,
    notify_host_via_email: Annotated[
        bool | None,
        "Set to `true` to notify the host and alternative host about the meeting cancellation via email. Set to `false` to avoid sending notifications.",  # noqa: E501
    ] = None,
    notify_registrants_of_cancellation: Annotated[
        bool | None,
        "Set to true to notify registrants via email about the meeting cancellation; false to send no notification. Defaults to false.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'meetingDelete'."]:
    """Delete a specific Zoom meeting or occurrence.

    Use this tool to delete a Zoom meeting. For recurring meetings, specify an `occurrence_id` to delete a single instance; otherwise, the entire series is removed. Appropriate scopes are required."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/meetings/{meetingId}".format(meetingId=meeting_id),  # noqa: UP032
            params=remove_none_values({
                "occurrence_id": meeting_occurrence_id,
                "schedule_for_reminder": notify_host_via_email,
                "cancel_meeting_reminder": notify_registrants_of_cancellation,
            }),
            method="DELETE",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "meeting:read:invitation:admin",
            "meeting:read",
            "meeting:read:admin",
            "meeting:read:invitation",
        ],
    )
)
async def get_zoom_meeting_invitation(
    context: ToolContext,
    zoom_meeting_id: Annotated[
        int, "The ID of the Zoom meeting. Store as a long integer since it can exceed 10 digits."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'meetingInvitation'."]:
    """Retrieve the invitation note for a Zoom meeting.

    Use this tool to get the meeting invitation note for a specified Zoom meeting. It requires that the host user has a Zoom Meetings Basic license or higher."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/meetings/{meetingId}/invitation".format(  # noqa: UP032
                meetingId=zoom_meeting_id
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "meeting:read:live_streaming_token:admin",
            "meeting_token:read:live_streaming",
            "meeting:read:live_streaming_token",
            "meeting_token:read:admin:live_streaming",
        ],
    )
)
async def get_zoom_meeting_live_stream_token(
    context: ToolContext,
    zoom_meeting_id: Annotated[
        int,
        "The ID of the Zoom meeting for which a live stream join token is required. Store as a long integer as IDs can exceed 10 digits.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'meetingLiveStreamingJoinToken'."]:
    """Obtain a join token for Zoom meeting live streaming.

    Use this tool to get a join token that allows a recording bot to connect to a Zoom meeting for live streaming. Requires a Pro or higher plan and enabled livestreaming settings. Supports both regular and raw streaming."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/meetings/{meetingId}/jointoken/live_streaming".format(  # noqa: UP032
                meetingId=zoom_meeting_id
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "meeting:read:local_archiving_token:admin",
            "meeting_token:read:admin:local_archiving",
        ],
    )
)
async def get_meeting_archive_token(
    context: ToolContext,
    meeting_id: Annotated[
        int, "The Zoom meeting's ID, stored as a long format integer. Can exceed 10 digits."
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'meetingLocalArchivingArchiveToken'."
]:
    """Retrieve a meeting's archive token for local archiving.

    Use this tool to obtain an archive token for a specified Zoom meeting, allowing a meeting SDK app or bot to access the meeting's raw audio and video media stream in real-time for local archiving purposes. Requires Pro or higher plan and enabled archive settings."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/meetings/{meetingId}/jointoken/local_archiving".format(  # noqa: UP032
                meetingId=meeting_id
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "meeting_token:read:admin:local_recording",
            "meeting:read:local_recording_token",
            "meeting:read:local_recording_token:admin",
            "meeting_token:read:local_recording",
        ],
    )
)
async def get_zoom_meeting_recording_join_token(
    context: ToolContext,
    meeting_id: Annotated[
        int,
        "The unique ID of the Zoom meeting. This should be stored as a long format integer to accommodate IDs exceeding 10 digits.",  # noqa: E501
    ],
    bypass_waiting_room: Annotated[
        bool | None,
        "Set to true to allow bypassing the waiting room and joining the meeting directly with the recording bot.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'meetingLocalRecordingJoinToken'."]:
    """Retrieve a join token for Zoom meeting local recording.

    This tool fetches the join token required for a recording bot to connect to a Zoom meeting and start local recording. It should be called when you need to enable a bot to record a meeting locally using the Zoom Meeting SDK. Ensure the 'Local recording' setting is enabled in the Zoom web portal before calling this tool."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/meetings/{meetingId}/jointoken/local_recording".format(  # noqa: UP032
                meetingId=meeting_id
            ),
            params=remove_none_values({"bypass_waiting_room": bypass_waiting_room}),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "meeting:read:livestream",
            "meeting:read",
            "meeting:read:admin",
            "meeting:read:livestream:admin",
        ],
    )
)
async def get_meeting_livestream_details(
    context: ToolContext,
    meeting_id: Annotated[
        str, "The unique identifier of the Zoom meeting to retrieve livestream details."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getMeetingLiveStreamDetails'."]:
    """Get livestream configuration details for a Zoom meeting.

    Use this tool to obtain details about a Zoom meeting's livestream configuration, including Stream URL, Stream Key, and Page URL. This tool is useful for checking livestream settings on a custom platform. The meeting host must be a licensed user with a Pro or higher plan, and livestream details must be pre-configured."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/meetings/{meetingId}/livestream".format(  # noqa: UP032
                meetingId=meeting_id
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "meeting:read:summary:admin",
            "meeting:read:summary",
            "meeting_summary:read",
            "meeting_summary:read:admin",
        ],
    )
)
async def get_meeting_summary(
    context: ToolContext,
    meeting_uuid: Annotated[
        str,
        "The UUID of the meeting or webinar. If it begins with a '/' or contains '//', double-encode before use.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'Getameetingsummary'."]:
    """Retrieve the summary of a Zoom meeting or webinar.

    Use this tool to get a summary of a Zoom meeting or webinar. Suitable for hosts with Pro, Business, or higher subscription plans who have enabled the appropriate settings. Does not support E2EE meetings."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/meetings/{meetingId}/meeting_summary".format(  # noqa: UP032
                meetingId=meeting_uuid
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "meeting:delete:summary",
            "meeting:delete:summary:admin",
            "meeting_summary:write",
            "meeting_summary:write:admin",
        ],
    )
)
async def delete_meeting_or_webinar_summary(
    context: ToolContext,
    meeting_uuid: Annotated[
        str, "The unique ID for the meeting. Double-encode if it starts with '/' or contains '//'."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'Deletemeetingorwebinarsummary'."]:
    """Delete the summary of a meeting or webinar.

    Use this tool to remove the summary associated with a specific meeting or webinar. Make sure the host has the necessary subscription and settings enabled. This action is not supported for E2EE meetings."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/meetings/{meetingId}/meeting_summary".format(  # noqa: UP032
                meetingId=meeting_uuid
            ),
            method="DELETE",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "meeting:write:open_app",
            "meeting:write:admin",
            "meeting:write:open_app:admin",
            "meeting:write",
        ],
    )
)
async def add_auto_open_app_to_meeting(
    context: ToolContext,
    meeting_id: Annotated[
        int,
        "The ID of the scheduled Zoom meeting. Ensure it is stored as a long format integer, as meeting IDs can exceed 10 digits.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'meetingAppAdd'."]:
    """Configure an app to auto-open in a scheduled Zoom meeting.

    This tool adds an app to automatically open in a scheduled Zoom meeting, given that the meeting is not live and the Zoom Apps Quick Launch Button is enabled. It does not open the app during a session."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/meetings/{meetingId}/open_apps".format(  # noqa: UP032
                meetingId=meeting_id
            ),
            method="POST",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "meeting:delete:open_app:admin",
            "meeting:write:admin",
            "meeting:delete:open_app",
            "meeting:write",
        ],
    )
)
async def delete_meeting_auto_open_app(
    context: ToolContext,
    meeting_id: Annotated[
        int,
        "The unique identifier for the meeting. Ensure it is stored as a long format integer, as IDs can exceed 10 digits.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'meetingAppDelete'."]:
    """Delete a meeting auto-open app in Zoom.

    Use this tool to delete a meeting auto-open app in Zoom. The meeting must not be live, and the Zoom Apps Quick Launch Button setting must be enabled. Appropriate scopes are required."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/meetings/{meetingId}/open_apps".format(  # noqa: UP032
                meetingId=meeting_id
            ),
            method="DELETE",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "meeting:read:list_polls",
            "meeting:read",
            "meeting:read:admin",
            "meeting:read:list_polls:admin",
        ],
    )
)
async def list_zoom_meeting_polls(
    context: ToolContext,
    zoom_meeting_id: Annotated[
        int,
        "The ID of the Zoom meeting. Ensure it is stored as a long format number since IDs can exceed 10 digits.",  # noqa: E501
    ],
    query_anonymous_polls: Annotated[
        bool | None,
        "Set to true to query for polls with the Anonymous option enabled. False excludes them.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'meetingPolls'."]:
    """Retrieve all polls for a specified Zoom meeting.

    Use this tool to list all polls associated with a scheduled Zoom meeting. The meeting host must be of Pro user type or higher, and polls are only available for scheduled, not instant, meetings."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/meetings/{meetingId}/polls".format(  # noqa: UP032
                meetingId=zoom_meeting_id
            ),
            params=remove_none_values({"anonymous": query_anonymous_polls}),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "meeting:read:poll",
            "meeting:read",
            "meeting:read:admin",
            "meeting:read:poll:admin",
        ],
    )
)
async def get_zoom_meeting_poll_info(
    context: ToolContext,
    meeting_id: Annotated[
        int,
        "The unique ID of the Zoom meeting. Ensure it is stored as a long integer as it can exceed 10 digits.",  # noqa: E501
    ],
    poll_id: Annotated[
        str,
        "The unique identifier for the poll within a Zoom meeting. Required to retrieve poll details.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'meetingPollGet'."]:
    """Retrieve details of a specific Zoom meeting poll.

    Use this tool to get information about a specific poll in a Zoom meeting. This requires the meeting host to have a Pro or higher plan and to have enabled the Meeting Polls/Quizzes setting. Appropriate scopes are required for access."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/meetings/{meetingId}/polls/{pollId}".format(  # noqa: UP032
                meetingId=meeting_id, pollId=poll_id
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "meeting:delete:poll",
            "meeting:write:admin",
            "meeting:delete:poll:admin",
            "meeting:write",
        ],
    )
)
async def delete_zoom_meeting_poll(
    context: ToolContext,
    meeting_id: Annotated[
        int,
        "The unique identifier for the Zoom meeting. Use a long format integer as IDs can exceed 10 digits.",  # noqa: E501
    ],
    zoom_poll_id: Annotated[
        str,
        "The unique identifier for the poll to be deleted from a scheduled Zoom meeting. Required for poll deletion.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'meetingPollDelete'."]:
    """Delete a poll from a Zoom scheduled meeting.

    This tool deletes a poll from a scheduled Zoom meeting. Call it when you need to remove an existing poll. Prerequisites include a Pro host user type, an enabled polling feature, and a scheduled meeting. The tool is appropriate for users with the necessary scopes for managing Zoom meeting polls."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/meetings/{meetingId}/polls/{pollId}".format(  # noqa: UP032
                meetingId=meeting_id, pollId=zoom_poll_id
            ),
            method="DELETE",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "meeting:read:list_registrants:admin",
            "meeting:read",
            "meeting:read:admin",
            "meeting:read:list_registrants",
        ],
    )
)
async def list_zoom_meeting_registrants(
    context: ToolContext,
    meeting_id: Annotated[
        int,
        "The ID of the Zoom meeting. Store this as a long integer to accommodate large values over 10 digits.",  # noqa: E501
    ],
    meeting_occurrence_id: Annotated[
        str | None, "The unique identifier for a specific occurrence of a meeting or webinar."
    ] = None,
    registrant_status: Annotated[
        str | None, "Filter registrants by their status: `pending`, `approved`, or `denied`."
    ] = None,
    number_of_records_per_call: Annotated[
        int | None,
        "The number of registrant records to return in one API call. Determines the batch size.",
    ] = None,
    pagination_page_number_deprecated: Annotated[
        int | None, "Deprecated. Do not use. Use `next_page_token` for pagination instead."
    ] = None,
    pagination_next_page_token: Annotated[
        str | None, "Use this token to paginate through results. It expires in 15 minutes."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'meetingRegistrants'."]:
    """Retrieve registered users for a Zoom meeting.

    Use this tool to list all users registered for a specific Zoom meeting. It requires a Pro or higher plan and registration must be enabled for the meeting. Ideal for hosts or users with admin permissions to access detailed registrant information."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/meetings/{meetingId}/registrants".format(  # noqa: UP032
                meetingId=meeting_id
            ),
            params=remove_none_values({
                "occurrence_id": meeting_occurrence_id,
                "status": registrant_status,
                "page_size": number_of_records_per_call,
                "page_number": pagination_page_number_deprecated,
                "next_page_token": pagination_next_page_token,
            }),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "meeting:read:list_registration_questions",
            "meeting:read:list_registration_questions:admin",
            "meeting:read",
            "meeting:read:admin",
        ],
    )
)
async def get_zoom_meeting_registration_questions(
    context: ToolContext,
    zoom_meeting_id: Annotated[
        int,
        "The unique ID of the Zoom meeting. It should be stored as a long format integer to accommodate IDs that may exceed 10 digits.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'meetingRegistrantsQuestionsGet'."]:
    """Retrieve registration questions for a Zoom meeting.

    Use this tool to list the questions displayed to users registering for a specific Zoom meeting. Prerequisites include a Pro or higher Zoom plan and enabled registration for the meeting."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/meetings/{meetingId}/registrants/questions".format(  # noqa: UP032
                meetingId=zoom_meeting_id
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "meeting:read:registrant:admin",
            "meeting:read:registrant",
            "meeting:read",
            "meeting:read:admin",
        ],
    )
)
async def get_meeting_registrant_details(
    context: ToolContext,
    meeting_id: Annotated[
        int,
        "The unique ID of the Zoom meeting. Use a long integer format to ensure accuracy as IDs can exceed 10 digits.",  # noqa: E501
    ],
    registrant_id: Annotated[str, "The ID of the registrant whose details are to be retrieved."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'meetingRegistrantGet'."]:
    """Retrieve details of a Zoom meeting registrant.

    Use this tool to fetch detailed information about a specific user registered for a Zoom meeting. It requires meeting host or administrative credentials."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/meetings/{meetingId}/registrants/{registrantId}".format(  # noqa: UP032
                meetingId=meeting_id, registrantId=registrant_id
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "meeting:delete:registrant",
            "meeting:delete:registrant:admin",
            "meeting:write:admin",
            "meeting:write",
        ],
    )
)
async def delete_meeting_registrant(
    context: ToolContext,
    meeting_id: Annotated[int, "The unique identifier for the Zoom meeting."],
    registrant_id: Annotated[
        str, "The unique identifier for the meeting registrant to be deleted."
    ],
    meeting_occurrence_id: Annotated[
        str | None,
        "The ID for a specific occurrence of a recurring Zoom meeting. Required if `registration_type` is 2 or 3.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'meetingregistrantdelete'."]:
    """Remove a registrant from a Zoom meeting.

    Use this tool to delete a registrant from a Zoom meeting. It requires the host to have a Pro or higher plan and registration enabled for the meeting. For recurring meetings, the `occurrence_id` field may be required based on the `registration_type`. Ensure the necessary OAuth scopes are present to perform this action."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/meetings/{meetingId}/registrants/{registrantId}".format(  # noqa: UP032
                meetingId=meeting_id, registrantId=registrant_id
            ),
            params=remove_none_values({"occurrence_id": meeting_occurrence_id}),
            method="DELETE",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "meeting:read",
            "meeting:read:admin",
            "meeting:read:survey:admin",
            "meeting:read:survey",
        ],
    )
)
async def get_meeting_survey_info(
    context: ToolContext,
    meeting_id: Annotated[
        int,
        "The unique identifier for a Zoom meeting. Should be stored as a long-format integer to accommodate IDs longer than 10 digits.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'meetingSurveyGet'."]:
    """Retrieve details about a Zoom meeting survey.

    This tool retrieves information about a specified Zoom meeting survey. It is useful for Pro users who have the Meeting Survey feature enabled and require insights into scheduled meetings. Note: Instant meetings do not support surveys."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/meetings/{meetingId}/survey".format(meetingId=meeting_id),  # noqa: UP032
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "meeting:delete:survey:admin",
            "meeting:write:admin",
            "meeting:delete:survey",
            "meeting:write",
        ],
    )
)
async def delete_zoom_meeting_survey(
    context: ToolContext,
    zoom_meeting_id: Annotated[
        int,
        "The ID of the scheduled Zoom meeting. Store as a long format integer due to its potential size exceeding 10 digits.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'meetingSurveyDelete'."]:
    """Delete a scheduled Zoom meeting survey.

    Use this tool to delete a survey associated with a scheduled Zoom meeting. Ensure the host is a Pro user with the Meeting Survey feature enabled. This tool is suitable for cases involving scheduled meetings, excluding instant meetings."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/meetings/{meetingId}/survey".format(  # noqa: UP032
                meetingId=zoom_meeting_id
            ),
            method="DELETE",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "meeting:read:token",
            "meeting:read:token:admin",
            "meeting:read",
            "meeting:read:admin",
        ],
    )
)
async def get_zoom_meeting_caption_token(
    context: ToolContext,
    zoom_meeting_id: Annotated[
        int,
        "The ID of the Zoom meeting. Store as a long format integer, since meeting IDs can exceed 10 digits.",  # noqa: E501
    ],
    meeting_token_type: Annotated[
        str | None, "The type of meeting token to retrieve, defaults to 'closed_caption_token'."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'meetingToken'."]:
    """Retrieve a closed caption token for a Zoom meeting.

    Retrieves a closed caption token for a specified Zoom meeting, allowing integration with third-party closed captioning services. Ensure the Closed Captioning setting is enabled in the Zoom portal."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/meetings/{meetingId}/token".format(  # noqa: UP032
                meetingId=zoom_meeting_id
            ),
            params=remove_none_values({"type": meeting_token_type}),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "meeting:read:past_meeting",
            "meeting:read",
            "meeting:read:admin",
            "meeting:read:past_meeting:admin",
        ],
    )
)
async def get_past_meeting_details(
    context: ToolContext,
    meeting_identifier: Annotated[
        str, "The ID or UUID of the meeting. Double encode if UUID starts with '/' or contains '//'"
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'pastMeetingDetails'."]:
    """Fetch details of a past Zoom meeting.

    Use this tool to obtain information about a Zoom meeting that has already ended and took place within the last year. It provides essential details about the meeting history."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/past_meetings/{meetingId}".format(  # noqa: UP032
                meetingId=meeting_identifier
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "meeting:read:list_past_instances",
            "meeting:read",
            "meeting:read:admin",
            "meeting:read:list_past_instances:admin",
        ],
    )
)
async def get_past_zoom_meetings(
    context: ToolContext,
    past_meeting_id: Annotated[
        int,
        "The ID of the past meeting to retrieve instances for. Must be a meeting that has concluded within the past 15 months.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'pastMeetings'."]:
    """Retrieve past instances of Zoom meetings.

    Use this tool to get a list of past meeting instances for a specified Zoom meeting ID. It returns instances of meetings that have concluded and are within the past 15 months."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/past_meetings/{meetingId}/instances".format(  # noqa: UP032
                meetingId=past_meeting_id
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "meeting:read",
            "meeting:read:admin",
            "meeting:read:list_past_participants:admin",
            "meeting:read:list_past_participants",
        ],
    )
)
async def get_past_meeting_participants(
    context: ToolContext,
    meeting_id: Annotated[
        str,
        "The meeting's ID or UUID. If UUID begins with '/' or contains '//', double-encode before using.",  # noqa: E501
    ],
    number_of_records_per_page: Annotated[
        int | None,
        "The number of participant records to return in a single API call for a past meeting.",
    ] = None,
    pagination_next_page_token: Annotated[
        str | None, "Token for paginating through large result sets, expires after 15 minutes."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'pastMeetingParticipants'."]:
    """Retrieve participants from a past Zoom meeting.

    Call this tool to get information on participants from a past Zoom meeting. Returns data only if there's more than one participant. Ensure to implement a delay if data isn't fully processed, especially for large meetings. Requires a Pro or higher Zoom account."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/past_meetings/{meetingId}/participants".format(  # noqa: UP032
                meetingId=meeting_id
            ),
            params=remove_none_values({
                "page_size": number_of_records_per_page,
                "next_page_token": pagination_next_page_token,
            }),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "meeting:read",
            "meeting:read:admin",
            "meeting:read:list_poll_results",
            "meeting:read:list_poll_results:admin",
        ],
    )
)
async def list_past_meeting_polls(
    context: ToolContext,
    meeting_id: Annotated[
        str,
        "The meeting's ID or UUID. Double-encode UUIDs with '/' or '//' before making a request.",
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listPastMeetingPolls'."]:
    """Retrieve poll results for a past Zoom meeting.

    Use this tool to get the poll results from a specific past Zoom meeting. The meeting must be scheduled, and the host must have a Pro account to access this feature."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/past_meetings/{meetingId}/polls".format(  # noqa: UP032
                meetingId=meeting_id
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "meeting:read:past_qa:admin",
            "meeting:read",
            "meeting:read:admin",
            "meeting:read:past_qa",
        ],
    )
)
async def get_zoom_past_meeting_qa(
    context: ToolContext,
    zoom_meeting_identifier: Annotated[
        str, "The meeting ID or UUID. Double-encode UUIDs starting with '/' or containing '//'."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listPastMeetingQA'."]:
    """Retrieve Q&A from a specific past Zoom meeting.

    This tool retrieves the questions and answers from a specific Zoom meeting that has already ended. It can only be used if the Q&A feature was enabled for the meeting and the meeting occurred within the last 15 months. Ideal for obtaining detailed meeting insights and follow-ups."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/past_meetings/{meetingId}/qa".format(  # noqa: UP032
                meetingId=zoom_meeting_identifier
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "meeting:read:list_templates",
            "meeting:read",
            "meeting:read:admin",
            "meeting:read:list_templates:admin",
        ],
    )
)
async def list_zoom_meeting_templates(
    context: ToolContext,
    zoom_user_id: Annotated[
        str, "The user ID to retrieve meeting templates. Use 'me' for user-level apps."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listMeetingTemplates'."]:
    """Retrieve Zoom meeting templates for a user.

    Fetch the available Zoom meeting templates for a specified user. This requires the user to have at least a Zoom Meetings Basic license. Use the `me` keyword for user-level apps instead of `userId`. Access to this endpoint requires specific Zoom scopes: `meeting:read` or `meeting:read:admin`. Ideal for managing and understanding meeting template configurations."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/users/{userId}/meeting_templates".format(  # noqa: UP032
                userId=zoom_user_id
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "meeting:read:list_meetings:admin",
            "meeting:read",
            "meeting:read:admin",
            "meeting:read:list_meetings",
        ],
    )
)
async def list_zoom_scheduled_meetings(
    context: ToolContext,
    zoom_user_identifier: Annotated[
        str, "The user's Zoom ID, email, or 'me' for user-level apps to list scheduled meetings."
    ],
    meeting_type: Annotated[
        str | None,
        "Specify the type of meeting to retrieve: 'scheduled', 'live', 'upcoming', 'upcoming_meetings', or 'previous_meetings'.",  # noqa: E501
    ] = None,
    records_per_page: Annotated[
        int | None,
        "The number of meeting records to return in each API call. Helps paginate results for larger datasets.",  # noqa: E501
    ] = None,
    pagination_next_page_token: Annotated[
        str | None, "Token to paginate through large result sets. Expires in 15 minutes."
    ] = None,
    current_page_number: Annotated[
        int | None,
        "The current page number for the returned records when fetching scheduled meetings.",
    ] = None,
    start_date: Annotated[
        str | None, "Specify the start date for listing meetings. Format should be 'YYYY-MM-DD'."
    ] = None,
    end_date: Annotated[
        str | None, "The end date for retrieving scheduled meetings. Format should be YYYY-MM-DD."
    ] = None,
    meeting_timezone: Annotated[
        str | None,
        "Specify the timezone for the 'from' and 'to' date values. Refer to the Zoom API timezone list for supported formats.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'meetings'."]:
    """Retrieve a Zoom user's scheduled meetings.

    Use this tool to list a Zoom user's scheduled meetings. It supports only scheduled, unexpired meetings and returns up to 6 months of data for upcoming or previous meetings. Suitable for user-level and admin-level apps using 'meeting:read' scopes."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/users/{userId}/meetings".format(  # noqa: UP032
                userId=zoom_user_identifier
            ),
            params=remove_none_values({
                "type": meeting_type,
                "page_size": records_per_page,
                "next_page_token": pagination_next_page_token,
                "page_number": current_page_number,
                "from": start_date,
                "to": end_date,
                "timezone": meeting_timezone,
            }),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "meeting:read:list_upcoming_meetings",
            "meeting:read:list_upcoming_meetings:admin",
            "meeting:read",
            "meeting:read:admin",
        ],
    )
)
async def list_upcoming_zoom_meetings(
    context: ToolContext,
    zoom_user_identifier: Annotated[
        str,
        "The Zoom user's ID or email. Use 'me' for user-level apps to refer to the current user.",
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listUpcomingMeeting'."]:
    """Fetches upcoming Zoom meetings for a user.

    Fetches a list of upcoming meetings scheduled or invited to within the next 24 hours for a specified Zoom user. Use 'me' as the user ID for user-level apps. Requires Calendar and Contacts Integration for third-party invites."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/users/{userId}/upcoming_meetings".format(  # noqa: UP032
                userId=zoom_user_identifier
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "pac:read",
            "pac:read:list_pac_accounts:admin",
            "pac:read:list_pac_accounts",
            "pac:read:admin",
        ],
    )
)
async def get_user_audio_conferences(
    context: ToolContext,
    user_identifier: Annotated[
        str, "The user's ID or email. Use 'me' for user-level apps to represent the current user."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'userPACs'."]:
    """Retrieve a list of user's personal audio conference accounts.

    Call this tool to obtain a list of a user's personal audio conference (PAC) accounts. It is useful for users with Pro or higher Zoom plans who want to manage or monitor their audio conference capabilities. Use 'me' as the userId for user-level apps."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/users/{userId}/pac".format(userId=user_identifier),  # noqa: UP032
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom", scopes=["report:read:admin", "report:read:user_activities:admin"]
    )
)
async def get_zoom_user_activity_logs(
    context: ToolContext,
    start_date: Annotated[
        str | None,
        "Start date for the activity logs report, in YYYY-MM-DD format. Must be within the last six months.",  # noqa: E501
    ] = None,
    end_date_for_activity_logs: Annotated[
        str | None,
        "The end date up to which to view the activity logs report. Must specify within the last six months.",  # noqa: E501
    ] = None,
    records_per_page: Annotated[
        int | None,
        "Specifies the number of activity log records to retrieve in one API call. Adjust for batch processing of data.",  # noqa: E501
    ] = None,
    pagination_next_page_token: Annotated[
        str | None,
        "Token used for paginating through large sets of user activity logs. Use the token received from the previous response to access the next set of results.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'reportSignInSignOutActivities'."]:
    """Retrieve Zoom user sign in and sign out activity reports.

    Use this tool to obtain a list of sign in and sign out activity logs for users under a Zoom account. Useful for tracking account activity and ensuring compliance with organizational policies. Requires a Pro or higher Zoom plan."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/report/activities",
            params=remove_none_values({
                "from": start_date,
                "to": end_date_for_activity_logs,
                "page_size": records_per_page,
                "next_page_token": pagination_next_page_token,
            }),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom", scopes=["report:read:admin", "report:read:billing:admin"]
    )
)
async def get_zoom_billing_report(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getBillingReport'."]:
    """Retrieve Zoom account department billing reports.

    Use this tool to obtain detailed billing reports for different departments within a Zoom account. Requires a Pro or higher account with Department Billing enabled and appropriate administrative read scopes."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/report/billing",
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom", scopes=["report:read:admin", "report:read:billing_invoice:admin"]
    )
)
async def fetch_zoom_billing_invoices(
    context: ToolContext,
    billing_report_id: Annotated[
        str,
        "Unique identifier for the billing report. Acquire this ID from the response of the Get Billing Reports API.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getBillingInvoicesReports'."]:
    """Retrieve billing invoices reports for a specific billing period.

    Use this tool to obtain department billing invoices reports from Zoom for a specified billing period. Ensure you have the necessary permissions and billing ID. Suitable for accounts with Pro or higher plans that have enabled Department Billing."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/report/billing/invoices",
            params=remove_none_values({"billing_id": billing_report_id}),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-zoom", scopes=["report:read:admin"]))
async def get_zoom_cloud_recording_report(
    context: ToolContext,
    start_date: Annotated[
        str,
        "Start date in 'yyyy-mm-dd' format. It must be up to 30 days before the end date and within the past six months.",  # noqa: E501
    ],
    end_date: Annotated[
        str,
        "End date in 'yyyy-mm-dd' format. Must be within one month of the start date and within the last six months.",  # noqa: E501
    ],
    group_identifier: Annotated[
        str | None,
        "The unique string ID of the group to retrieve cloud recording reports for. Obtainable via the List groups API.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'reportCloudRecording'."]:
    """Retrieve Zoom cloud recording usage report for a date range.

    Call this tool to get cloud recording usage reports from Zoom for a specific date range, subject to certain constraints. Reports can be retrieved for up to 30 days within the most recent six months, and only from one day before the current date. Requires a Pro or higher plan."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/report/cloud_recording",
            params=remove_none_values({
                "from": start_date,
                "to": end_date,
                "group_id": group_identifier,
            }),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-zoom", scopes=["report:read:admin"]))
async def get_zoom_daily_report(
    context: ToolContext,
    report_year: Annotated[
        int | None,
        "The year for which the Zoom usage report is requested. Must be a valid integer year.",
    ] = None,
    report_month: Annotated[
        int | None, "The month (1-12) for the report. Specify as an integer."
    ] = None,
    zoom_group_id: Annotated[
        str | None,
        "The ID of the Zoom group for which you want to retrieve the usage report. Use the 'List groups' API to find the ID. The report will only include users in this group.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'reportDaily'."]:
    """Retrieve daily Zoom usage statistics for account-wide overview.

    This tool retrieves a daily report detailing the account-wide usage of Zoom services, including new users, meetings, participants, and meeting minutes for each day in a specified month. Requires a Pro or higher plan and the `report:read:admin` scope."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/report/daily",
            params=remove_none_values({
                "year": report_year,
                "month": report_month,
                "group_id": zoom_group_id,
            }),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom", scopes=["report:read:admin", "report:read:list_history_meetings:admin"]
    )
)
async def get_zoom_history_meetings(
    context: ToolContext,
    start_date: Annotated[
        str,
        "The start date for the report in `yyyy-mm-dd` format. Ensure the date range is within one month.",  # noqa: E501
    ],
    end_date: Annotated[
        str,
        "The end date for the query in `yyyy-mm-dd` format. It defines the end of the one-month date range for the report.",  # noqa: E501
    ],
    query_date_type: Annotated[
        str | None,
        "Specifies whether to query by meeting's start time or end time. Use 'start_time' for start time and 'end_time' for end time. Defaults to 'start_time'.",  # noqa: E501
    ] = None,
    query_meeting_type: Annotated[
        str | None,
        "Specifies the type of meeting to query: 'all' for both meetings and webinars, 'meeting' for meetings only, and 'webinar' for webinars only.",  # noqa: E501
    ] = None,
    report_type: Annotated[
        str | None,
        "Specify the type of report to query: all, poll, survey, qa, resource, or reaction.",
    ] = None,
    search_keywords: Annotated[
        str | None,
        "Keywords for the meeting topic or meeting ID to filter the historical Zoom meetings and webinars.",  # noqa: E501
    ] = None,
    number_of_records_per_call: Annotated[
        int | None,
        "The maximum number of records to return in a single API call. Helps manage large data sets.",  # noqa: E501
    ] = None,
    pagination_next_page_token: Annotated[
        str | None, "Token for pagination of large result sets. Expires in 15 minutes."
    ] = None,
    group_identifier: Annotated[
        str | None,
        "The unique group ID to query members. Use the List groups API to obtain this ID. Only includes users from the specified group.",  # noqa: E501
    ] = None,
    query_meeting_features: Annotated[
        str | None,
        "Comma-separated list of meeting features to filter historical meetings. Options include features like `screen_sharing`, `video_on`, `poll`, etc.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'Gethistorymeetingandwebinarlist'."]:
    """Retrieve a list of historical Zoom meetings and webinars.

    This tool is used to fetch historical data of meetings and webinars from Zoom. It requires specific administrative read scopes and is subject to heavy rate limits, making it suitable for retrieving comprehensive reports of past Zoom events."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/report/history_meetings",
            params=remove_none_values({
                "from": start_date,
                "to": end_date,
                "date_type": query_date_type,
                "meeting_type": query_meeting_type,
                "report_type": report_type,
                "search_key": search_keywords,
                "page_size": number_of_records_per_call,
                "next_page_token": pagination_next_page_token,
                "group_id": group_identifier,
                "meeting_feature": query_meeting_features,
            }),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom", scopes=["report:read:meeting_activity_log:admin", "report:read:admin"]
    )
)
async def get_meeting_activity_logs(
    context: ToolContext,
    start_date: Annotated[
        str,
        "The start date for the report in 'yyyy-MM-dd' format. Ensure the range with 'to' is only one month.",  # noqa: E501
    ],
    end_date: Annotated[
        str,
        "The end date for fetching meeting activity logs in 'yyyy-MM-dd' format. Must be within one month of the start date.",  # noqa: E501
    ],
    activity_type: Annotated[
        str,
        "Specify the type of activity to filter logs. Options: All Activities, Meeting Created, Meeting Started, User Join, User Left, Remote Control, In-Meeting Chat, Meeting Ended.",  # noqa: E501
    ],
    number_of_records_per_call: Annotated[
        int | None,
        "Specify the number of records to be returned in a single API call. Adjust according to data needs and rate limits.",  # noqa: E501
    ] = None,
    pagination_token: Annotated[
        str | None, "Token for paginating through large sets of results. Expires in 15 minutes."
    ] = None,
    meeting_number: Annotated[
        str | None, "The unique identifier for the Zoom meeting. Required to fetch activity logs."
    ] = None,
    operator_name_or_email: Annotated[
        str | None, "An operator's name or email used to filter the meeting activity logs."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'reportMeetingactivitylogs'."]:
    """Retrieve a list of meeting activity logs from Zoom.

    Use this tool to get a detailed history of meeting activities on Zoom. Ensure the meeting audit trail log feature is enabled on your account before using this tool."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/report/meeting_activities",
            params=remove_none_values({
                "from": start_date,
                "to": end_date,
                "page_size": number_of_records_per_call,
                "next_page_token": pagination_token,
                "meeting_number": meeting_number,
                "search_key": operator_name_or_email,
                "activity_type": activity_type,
            }),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom", scopes=["report:read:admin", "report:read:meeting:admin"]
    )
)
async def get_zoom_meeting_report(
    context: ToolContext,
    zoom_meeting_identifier: Annotated[
        str, "The meeting's ID or UUID. Double encode UUIDs starting with '/' or containing '//'."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'reportMeetingDetails'."]:
    """Retrieve a detailed report for a past Zoom meeting.

    Call this tool to get a comprehensive report of a previously held Zoom meeting. Requires a Pro or higher plan, with appropriate OAuth scopes (`report:read:admin` or `report:read:meeting:admin`). Be aware of rate limits marked as 'Heavy'."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/report/meetings/{meetingId}".format(  # noqa: UP032
                meetingId=zoom_meeting_identifier
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=["report:read:admin", "report:read:list_meeting_participants:admin"],
    )
)
async def get_zoom_meeting_participants_report(
    context: ToolContext,
    meeting_identifier: Annotated[
        str,
        "The ID or UUID of the Zoom meeting. For meeting UUIDs starting with '/' or containing '//', double-encode before requesting.",  # noqa: E501
    ],
    records_per_page: Annotated[
        int | None, "The number of participant records to return in a single API call."
    ] = None,
    pagination_next_page_token: Annotated[
        str | None, "Token for fetching the next page of large result sets. Expires in 15 minutes."
    ] = None,
    include_registrant_id_in_report: Annotated[
        str | None, "Include 'registrant_id' in the response to see registrant ID attributes."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'reportMeetingParticipants'."]:
    """Get a report of past Zoom meeting participants.

    Call this tool to obtain a report of participants from a past Zoom meeting with two or more attendees, including the host. Useful for obtaining details on participant attendance and interaction in meetings that were not limited to a single participant."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/report/meetings/{meetingId}/participants".format(  # noqa: UP032
                meetingId=meeting_identifier
            ),
            params=remove_none_values({
                "page_size": records_per_page,
                "next_page_token": pagination_next_page_token,
                "include_fields": include_registrant_id_in_report,
            }),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom", scopes=["report:read:list_meeting_polls:admin", "report:read:admin"]
    )
)
async def get_zoom_meeting_poll_report(
    context: ToolContext,
    zoom_meeting_identifier: Annotated[
        str,
        "The meeting's ID or UUID. If the UUID begins with '/' or contains '//', double encode it.",
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'reportMeetingPolls'."]:
    """Fetches a report of poll results for a past Zoom meeting.

    Use this tool to retrieve the results of polls conducted during a past Zoom meeting. This is useful when you need to access detailed polling data post-meeting. Requires a Pro or higher plan and appropriate admin read permissions."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/report/meetings/{meetingId}/polls".format(  # noqa: UP032
                meetingId=zoom_meeting_identifier
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom", scopes=["report:read:admin", "report:read:meeting_qna:admin"]
    )
)
async def zoom_report_meeting_qa(
    context: ToolContext,
    meeting_identifier: Annotated[
        str, "Meeting's ID or UUID. Double-encode UUIDs if they begin with '/' or contain '//'."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'reportMeetingQA'."]:
    """Retrieve a report on past Zoom meeting Q&A sessions.

    Use this tool to access reports on questions asked and answered by participants in past Zoom meetings. Suitable for administrators with Pro plan or higher. Requires appropriate OAuth scopes."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/report/meetings/{meetingId}/qa".format(  # noqa: UP032
                meetingId=meeting_identifier
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom", scopes=["report:read:meeting_survey:admin", "report:read:admin"]
    )
)
async def get_zoom_meeting_survey_report(
    context: ToolContext,
    meeting_identifier: Annotated[
        str, "The ID or UUID of the Zoom meeting. Double-encode UUIDs with '/' or '//' characters."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'reportMeetingSurvey'."]:
    """Retrieve report details of a Zoom meeting survey.

    Fetch a detailed report of a past Zoom meeting survey. Requires a Pro or higher Zoom plan and appropriate admin scopes. Useful for administrators who need insights into meeting feedback."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/report/meetings/{meetingId}/survey".format(  # noqa: UP032
                meetingId=meeting_identifier
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom", scopes=["report:read:admin", "report:read:operation_logs:admin"]
    )
)
async def retrieve_zoom_operation_logs(
    context: ToolContext,
    start_date_for_report: Annotated[
        str,
        "Start date for the report in 'yyyy-mm-dd' or 'yyyy-MM-dd HH:mm' format. The report covers a one-month period.",  # noqa: E501
    ],
    end_date: Annotated[
        str,
        "End date for the report in 'yyyy-mm-dd' or 'yyyy-MM-dd HH:mm' format, marking the close of the desired data range.",  # noqa: E501
    ],
    records_per_page: Annotated[
        int | None,
        "Specify the number of records to return in a single call, optimizing pagination for large datasets.",  # noqa: E501
    ] = None,
    pagination_next_page_token: Annotated[
        str | None,
        "Token for paginating large result sets in operation logs. Expires in 15 minutes.",
    ] = None,
    filter_by_category_type: Annotated[
        str | None,
        "Optional argument to filter the response by specific category type, such as 'all', 'user', or 'recording'.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'reportOperationLogs'."]:
    """Retrieve Zoom operation logs for auditing admin and user activity.

    This tool retrieves the Zoom operation logs report for a specified period of time. It audits activities like adding users, altering account settings, and deleting recordings. Can be called to monitor and review administration or user operations, ensuring compliance and auditing purposes. Requires a Pro or higher plan."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/report/operationlogs",
            params=remove_none_values({
                "from": start_date_for_report,
                "to": end_date,
                "page_size": records_per_page,
                "next_page_token": pagination_next_page_token,
                "category_type": filter_by_category_type,
            }),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom", scopes=["report:read:telephone:admin", "report:read:admin"]
    )
)
async def get_zoom_telephone_report(
    context: ToolContext,
    start_date: Annotated[
        str,
        "Start date for the report in 'yyyy-mm-dd' format. The date range should cover only one month.",  # noqa: E501
    ],
    end_date: Annotated[
        str,
        "The end date for the report in 'yyyy-mm-dd' format. It should be within one month of the start date.",  # noqa: E501
    ],
    audio_type: Annotated[
        str | None,
        "Specify the type of audio. Options: '1' for Toll-free Call-in & Call-out, '2' for Toll, or '3' for SIP Connected Audio.",  # noqa: E501
    ] = None,
    date_query_type: Annotated[
        str | None,
        "Specifies the date type for the report query. Options: 'start_time', 'end_time', 'meeting_start_time', or 'meeting_end_time'. Defaults to 'start_time'.",  # noqa: E501
    ] = None,
    records_per_page: Annotated[
        int | None,
        "Specify the number of records to return in a single API call. Useful for managing large data sets efficiently.",  # noqa: E501
    ] = None,
    pagination_page_number: Annotated[
        int | None,
        "Deprecated. Use the page number for current records pagination unless using 'meeting_start_time' or 'meeting_end_time'.",  # noqa: E501
    ] = None,
    pagination_next_page_token: Annotated[
        str | None,
        "Token for retrieving the next set of results in large data sets. Expires in 15 minutes.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'reportTelephone'."]:
    """Retrieve Zoom telephone report for specified meetings.

    Use this tool to access detailed telephone reports for Zoom meetings, showing who dialed in via phone, the numbers used, and additional information. Useful for analyzing audio conferencing data within a specified timeframe."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/report/telephone",
            params=remove_none_values({
                "type": audio_type,
                "query_date_type": date_query_type,
                "from": start_date,
                "to": end_date,
                "page_size": records_per_page,
                "page_number": pagination_page_number,
                "next_page_token": pagination_next_page_token,
            }),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=["report:read:upcoming_meetings_webinars:admin", "report:read:admin"],
    )
)
async def list_zoom_upcoming_events(
    context: ToolContext,
    start_date: Annotated[
        str,
        "Start date in 'yyyy-mm-dd' format. The date range with 'end_date' should be within one month.",  # noqa: E501
    ],
    end_date: Annotated[
        str,
        "The end date for the report in 'yyyy-mm-dd' format, within one month of the start date.",
    ],
    records_per_page: Annotated[
        int | None, "Number of records to return in a single API call, used for paginating results."
    ] = None,
    pagination_token: Annotated[
        str | None, "Token for paginating through large result sets, expires in 15 minutes."
    ] = None,
    event_type_to_query: Annotated[
        str | None,
        "Specify the type of Zoom event to query: 'meeting', 'webinar', or 'all'. Defaults to 'all'.",  # noqa: E501
    ] = None,
    group_identifier: Annotated[
        str | None,
        "The ID of the group for filtering events to include only those where the host is a member. Obtainable via the Zoom 'List groups' API.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'reportUpcomingEvents'."]:
    """Retrieve upcoming Zoom meetings and webinars.

    Use this tool to list upcoming Zoom meetings and webinar events within a specified one-month period. Requires a Pro or higher plan and appropriate OAuth scopes."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/report/upcoming_events",
            params=remove_none_values({
                "from": start_date,
                "to": end_date,
                "page_size": records_per_page,
                "next_page_token": pagination_token,
                "type": event_type_to_query,
                "group_id": group_identifier,
            }),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom", scopes=["report:read:admin", "report:read:list_users:admin"]
    )
)
async def get_zoom_host_report(
    context: ToolContext,
    start_date: Annotated[
        str,
        "Start date of the report in 'yyyy-mm-dd' format. The date range for the report must be within one month.",  # noqa: E501
    ],
    end_date: Annotated[
        str,
        "End date for the report in 'yyyy-mm-dd' format. Must be at most one month after the 'from' date.",  # noqa: E501
    ],
    host_activity_type: Annotated[
        str | None, "Specify 'active' for active hosts or 'inactive' for inactive hosts."
    ] = None,
    record_count_per_api_call: Annotated[
        int | None,
        "Specify the number of records to return in each API call, controlling the data amount per request.",  # noqa: E501
    ] = None,
    current_page_number: Annotated[
        int | None, "The page number to retrieve for the host activity report."
    ] = None,
    next_page_pagination_token: Annotated[
        str | None,
        "Token for paginating large result sets in host reports, with a 15-minute expiration.",
    ] = None,
    zoom_group_id: Annotated[
        str | None,
        "The ID for the group. Use the List groups API to obtain this, as the response includes only users in the specified group.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'reportUsers'."]:
    """Retrieve Zoom host activity reports for a specified period.

    Fetch detailed reports of Zoom hosts' activities over a specified date range within the last six months. It provides lists of active or inactive hosts, detailing meetings, participants, and meeting minutes. Applicable for users with a Pro or higher plan."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/report/users",
            params=remove_none_values({
                "type": host_activity_type,
                "from": start_date,
                "to": end_date,
                "page_size": record_count_per_api_call,
                "page_number": current_page_number,
                "next_page_token": next_page_pagination_token,
                "group_id": zoom_group_id,
            }),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(id="arcade-zoom", scopes=["report:read:admin", "report:read:user:admin"])
)
async def get_zoom_meeting_reports(
    context: ToolContext,
    report_start_date: Annotated[
        str,
        "Start date for the report in 'yyyy-mm-dd' format. Ensure the date range with 'to' is within one month.",  # noqa: E501
    ],
    end_date: Annotated[
        str,
        "The end date of the report in 'yyyy-mm-dd' format. The date range should be within one month of the start date and must fall within the past six months.",  # noqa: E501
    ],
    zoom_user_identifier: Annotated[
        str, "The user ID or email address to identify the user. Use 'me' for user-level apps."
    ],
    number_of_records_per_page: Annotated[
        int | None,
        "The number of records to return in a single API call. Determines the page size for report data retrieval.",  # noqa: E501
    ] = None,
    pagination_token: Annotated[
        str | None, "Token to paginate through large result sets, expiring after 15 minutes."
    ] = None,
    meeting_type: Annotated[
        str | None,
        "Specify the type of past meetings to query. Options: 'past' for all past meetings, 'pastOne' for a single past user meeting, 'pastJoined' for all past meetings the account's users hosted or joined.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'reportMeetings'."]:
    """Retrieve details of past Zoom meetings and webinars.

    This tool retrieves reports on past Zoom meetings and webinars for a specified period within the past six months. It is suitable for meetings with two or more participants and requires a Pro or higher plan. Ensure proper OAuth scopes are set for access."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/report/users/{userId}/meetings".format(  # noqa: UP032
                userId=zoom_user_identifier
            ),
            params=remove_none_values({
                "from": report_start_date,
                "to": end_date,
                "page_size": number_of_records_per_page,
                "next_page_token": pagination_token,
                "type": meeting_type,
            }),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom", scopes=["report:read:admin", "report:read:webinar:admin"]
    )
)
async def get_zoom_webinar_report(
    context: ToolContext,
    webinar_identifier: Annotated[
        str,
        "The ID or UUID of the webinar. Use webinar ID for latest instance or UUID, which may need double encoding if it starts with '/' or contains '//'.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'reportWebinarDetails'."]:
    """Retrieve details of a past Zoom webinar.

    Use this tool to get a report containing the details of a past Zoom webinar. It requires a Pro or higher plan with the Webinar add-on and specific scopes like `report:read:admin`. Useful for accessing comprehensive webinar data."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/report/webinars/{webinarId}".format(  # noqa: UP032
                webinarId=webinar_identifier
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=["report:read:list_webinar_participants:admin", "report:read:admin"],
    )
)
async def get_webinar_participant_report(
    context: ToolContext,
    webinar_identifier: Annotated[
        str, "The webinar's ID or UUID. Double-encode UUIDs starting with '/' or containing '//'."
    ],
    number_of_records_per_call: Annotated[
        int | None,
        "Specifies the number of records to return in a single API call for webinar participant reports.",  # noqa: E501
    ] = None,
    pagination_token: Annotated[
        str | None,
        "Token for paginating through large sets of webinar participant data. Expires in 15 minutes.",  # noqa: E501
    ] = None,
    include_registrant_id: Annotated[
        str | None,
        "Specify if the registrant's unique ID should be included in the webinar participant report.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'reportWebinarParticipants'."]:
    """Retrieve detailed report on webinar attendees.

    Fetches a comprehensive report of each participant in a specified webinar from the last 6 months. Requires a Pro or higher plan with Webinar add-on enabled. Suitable for fetching participant data when analyzing webinar attendance and engagement."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/report/webinars/{webinarId}/participants".format(  # noqa: UP032
                webinarId=webinar_identifier
            ),
            params=remove_none_values({
                "page_size": number_of_records_per_call,
                "next_page_token": pagination_token,
                "include_fields": include_registrant_id,
            }),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom", scopes=["report:read:admin", "report:read:list_webinar_polls:admin"]
    )
)
async def retrieve_zoom_webinar_polls_report(
    context: ToolContext,
    webinar_id: Annotated[
        str,
        "The webinar's ID or UUID. If using a UUID starting with '/' or containing '//', double-encode it.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'reportWebinarPolls'."]:
    """Retrieve report on past webinar polls for a Zoom webinar.

    Use this tool to retrieve detailed reports on past webinar polls conducted during a specific Zoom webinar. Useful for analyzing poll responses and participation in webinars. Requires a Pro or higher plan with Webinar add-on. Ensure the appropriate OAuth scopes are configured."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/report/webinars/{webinarId}/polls".format(  # noqa: UP032
                webinarId=webinar_id
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom", scopes=["report:read:admin", "report:read:webinar_qna:admin"]
    )
)
async def get_zoom_webinar_qa_report(
    context: ToolContext,
    webinar_identifier: Annotated[
        str,
        "The ID or UUID of the webinar. Double-encode if UUID starts with '/' or contains '//'.",
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'reportWebinarQA'."]:
    """Retrieve report on questions and answers from Zoom webinars.

    Fetches a detailed report of questions asked by participants and the responses given by panelists, co-hosts, and hosts during past webinars. Requires Pro or higher plan with Webinar add-on."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/report/webinars/{webinarId}/qa".format(  # noqa: UP032
                webinarId=webinar_identifier
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom", scopes=["report:read:admin", "report:read:webinar_survey:admin"]
    )
)
async def get_zoom_webinar_survey_report(
    context: ToolContext,
    zoom_webinar_id: Annotated[
        str,
        "The ID or UUID of the webinar. If using a UUID starting with '/' or containing '//', double-encode it.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'reportWebinarSurvey'."]:
    """Retrieve a report on past webinar survey results.

    Fetches detailed reports of webinars surveys from Zoom. Useful for analyzing feedback collected during webinars. Requires a Pro or higher plan with the Webinar add-on enabled."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/report/webinars/{webinarId}/survey".format(  # noqa: UP032
                webinarId=zoom_webinar_id
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom", scopes=["sip_phone:read:admin", "sip_phone:read:list_sip_phones:admin"]
    )
)
async def list_sip_phones(
    context: ToolContext,
    user_identifier: Annotated[
        str | None,
        "A user's username or email to filter SIP phone integrations for that specific user.",
    ] = None,
    records_per_page: Annotated[
        int | None,
        "The number of SIP phone records to return in a single API call. Adjust for desired page size.",  # noqa: E501
    ] = None,
    pagination_token: Annotated[
        str | None,
        "Token for paginating through large SIP phone result sets. Expires in 15 minutes.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'ListSIPPhonePhones'."]:
    """Retrieve a list of SIP phones on a Zoom account.

    Use this tool to list all SIP phones integrated with a Zoom account, specifically for Cisco and Avaya PBX systems. This is useful for administrators who need to manage SIP integrations. Ensure SIP Phone Integration is enabled through Zoom's sales team."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/sip_phones/phones",
            params=remove_none_values({
                "search_key": user_identifier,
                "page_size": records_per_page,
                "next_page_token": pagination_token,
            }),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom", scopes=["sip_phone:delete:sip_phone:admin", "sip_phone:write:admin"]
    )
)
async def delete_zoom_sip_phone(
    context: ToolContext,
    sip_phone_id: Annotated[
        str,
        "The unique identifier for the SIP phone to be deleted, obtainable from the List SIP phones API.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteSIPPhonePhones'."]:
    """Delete a SIP phone from a Zoom account.

    Use this tool to delete a SIP phone from a Zoom account. Ensure the SIP Phone Integration is enabled and only applicable for Cisco and Avaya PBX systems. Requires appropriate admin scopes."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/sip_phones/phones/{phoneId}".format(phoneId=sip_phone_id),  # noqa: UP032
            method="DELETE",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-zoom", scopes=["tsp:read:tsp:admin", "tsp:read:admin"]))
async def get_tsp_info(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'tsp'."]:
    """Retrieve Telephony Service Provider (TSP) info for an account.

    Use this tool to get information about the Telephony Service Provider (TSP) configured at the account level on Zoom. Ensure that TSP audio is enabled on the Zoom account and that the account has a Pro or higher subscription plan. Requires `tsp:read:admin` scope."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/tsp",
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "tsp:read:list_tsp_accounts",
            "tsp:read:list_tsp_accounts:admin",
            "tsp:read",
            "tsp:read:admin",
        ],
    )
)
async def list_user_tsp_accounts(
    context: ToolContext,
    user_identifier: Annotated[
        str, "The user ID or email address of the user. Use 'me' for user-level apps."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'userTSPs'."]:
    """Retrieve a user's TSP accounts on Zoom.

    Use this tool to list all TSP (Telephony Service Provider) accounts for a Zoom user. Requires TSP audio to be enabled and a Pro or higher subscription plan."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/users/{userId}/tsp".format(userId=user_identifier),  # noqa: UP032
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=["tsp:read:tsp_account", "tsp:read", "tsp:read:tsp_account:admin", "tsp:read:admin"],
    )
)
async def get_user_tsp_details(
    context: ToolContext,
    user_identifier: Annotated[
        str, "The user ID or email address of the user. Use 'me' for user-level apps."
    ],
    tsp_account_id: Annotated[
        str, "The ID of the TSP account to retrieve details for. It can either be '1' or '2'."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'userTSP'."]:
    """Retrieve TSP account details for a specific Zoom user.

    Fetch details of a Telephony Service Provider (TSP) account linked to a specific user in Zoom. Useful when needing information about TSP configurations for users. Requires TSP audio to be enabled and a Pro or higher Zoom subscription."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/users/{userId}/tsp/{tspId}".format(  # noqa: UP032
                userId=user_identifier, tspId=tsp_account_id
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "tsp:write",
            "tsp:delete:tsp_account",
            "tsp:delete:tsp_account:admin",
            "tsp:write:admin",
        ],
    )
)
async def delete_user_tsp_account(
    context: ToolContext,
    user_identifier: Annotated[
        str,
        "Specify the user's ID or email. Use 'me' for user-level apps to identify the current user.",  # noqa: E501
    ],
    tsp_account_id: Annotated[
        str, "The ID of the TSP account to be deleted, specified as a string."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'userTSPDelete'."]:
    """Delete a user's Telephony Service Provider account.

    This tool deletes a user's TSP account in Zoom. It requires that TSP audio is enabled and the account has a Pro or higher subscription plan."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/users/{userId}/tsp/{tspId}".format(  # noqa: UP032
                userId=user_identifier, tspId=tsp_account_id
            ),
            method="DELETE",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=["tracking_fields:read:admin", "tracking_field:read:list_tracking_fields:admin"],
    )
)
async def list_zoom_tracking_fields(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'trackingfieldList'."]:
    """Retrieve all tracking fields from your Zoom account.

    Use this tool to get a full list of tracking fields available on your Zoom account. Tracking fields are used to analyze and categorize Zoom usage within an organization. This tool requires a Business, Education, API, or higher plan and appropriate admin scopes."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/tracking_fields",
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=["tracking_fields:read:admin", "tracking_field:read:tracking_field:admin"],
    )
)
async def get_zoom_tracking_field_info(
    context: ToolContext,
    tracking_field_id: Annotated[
        str,
        "The unique identifier for the Zoom tracking field you want to retrieve information about. Must be a string.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'trackingfieldGet'."]:
    """Retrieve details about a specific Zoom tracking field.

    Use this tool to obtain information about a specific tracking field in a Zoom account. It's ideal for users with a Business, Education, API, or higher plan and appropriate admin permissions. Call this tool when detailed knowledge of a Zoom tracking field is needed."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/tracking_fields/{fieldId}".format(  # noqa: UP032
                fieldId=tracking_field_id
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=["tracking_field:delete:tracking_field:admin", "tracking_fields:write:admin"],
    )
)
async def delete_zoom_tracking_field(
    context: ToolContext,
    tracking_field_id: Annotated[
        str,
        "The unique identifier of the tracking field to be deleted in Zoom. Required for the deletion process.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'trackingfieldDelete'."]:
    """Delete a tracking field in Zoom.

    Use this tool to delete a tracking field in Zoom if you have a Business, Education, API, or higher plan. Ensure the necessary scopes are available for this operation."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/tracking_fields/{fieldId}".format(  # noqa: UP032
                fieldId=tracking_field_id
            ),
            method="DELETE",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "webinar:delete:live_webinar_chat_message",
            "webinar:write:admin",
            "webinar:delete:live_webinar_chat_message:admin",
            "webinar:write",
        ],
    )
)
async def delete_webinar_chat_message(
    context: ToolContext,
    webinar_id: Annotated[
        int,
        "The unique ID of the webinar from which to delete the chat message. This should be an integer.",  # noqa: E501
    ],
    webinar_chat_message_id: Annotated[
        str,
        "The unique identifier for the webinar chat message to delete, encoded in base64 format.",
    ],
    webinar_chat_file_uuids: Annotated[
        str | None,
        "Comma-separated base64-encoded UUIDs for the live webinar chat files to identify specific chat data files.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteWebinarChatMessageById'."]:
    """Delete a message from a live Zoom webinar by ID.

    Use this tool to remove a specific message from an ongoing Zoom webinar chat by providing the message ID. Ensure that DLP for in-meeting chat is enabled and the necessary OAuth scopes are granted before calling this tool."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/live_webinars/{webinarId}/chat/messages/{messageId}".format(  # noqa: UP032
                webinarId=webinar_id, messageId=webinar_chat_message_id
            ),
            params=remove_none_values({"file_ids": webinar_chat_file_uuids}),
            method="DELETE",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "webinar:read:list_absentees",
            "webinar:read",
            "webinar:read:admin",
            "webinar:read:list_absentees:admin",
        ],
    )
)
async def get_webinar_absentees(
    context: ToolContext,
    webinar_id_or_uuid: Annotated[
        str,
        "The webinar's ID or UUID. If using a UUID starting with '/' or containing '//', double encode it.",  # noqa: E501
    ],
    webinar_occurrence_id: Annotated[
        str | None, "The ID of the specific webinar occurrence to retrieve absentees for."
    ] = None,
    number_of_records_per_call: Annotated[
        int | None, "The number of records to return in a single API call."
    ] = None,
    pagination_next_page_token: Annotated[
        str | None, "Token for pagination to access the next set of results. Expires in 15 minutes."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'webinarAbsentees'."]:
    """Retrieve a list of absentees from a Zoom webinar.

    This tool lists absentees of a specific Zoom webinar. It requires a Pro or higher plan with a Webinar add-on. Use this tool to find out who did not attend a past webinar."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/past_webinars/{webinarId}/absentees".format(  # noqa: UP032
                webinarId=webinar_id_or_uuid
            ),
            params=remove_none_values({
                "occurrence_id": webinar_occurrence_id,
                "page_size": number_of_records_per_call,
                "next_page_token": pagination_next_page_token,
            }),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "webinar:read",
            "webinar:read:admin",
            "webinar:read:list_past_instances",
            "webinar:read:list_past_instances:admin",
        ],
    )
)
async def list_past_webinars(
    context: ToolContext,
    webinar_id: Annotated[
        int, "The unique identifier for a specific Zoom webinar. It should be an integer value."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'pastWebinars'."]:
    """Retrieve details of past Zoom webinar instances.

    Use this tool to list instances of past webinars conducted via Zoom. It requires a Pro or higher plan with a Webinar plan add-on. It accesses webinar data for specified webinar IDs."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/past_webinars/{webinarId}/instances".format(  # noqa: UP032
                webinarId=webinar_id
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "webinar:read:list_past_participants:admin",
            "webinar:read",
            "webinar:read:list_past_participants",
            "webinar:read:admin",
        ],
    )
)
async def retrieve_webinar_participants(
    context: ToolContext,
    webinar_id: Annotated[
        str,
        "The ID or UUID of the webinar. If it starts with '/' or contains '//' ensure it is double encoded.",  # noqa: E501
    ],
    number_of_records_per_call: Annotated[
        int | None,
        "Specify the number of participant records to retrieve in a single API call. This helps control the size of each data page.",  # noqa: E501
    ] = None,
    pagination_token_for_participants: Annotated[
        str | None, "Token to fetch the next page of webinar participants. Expires in 15 minutes."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listWebinarParticipants'."]:
    """Retrieve participants of a past Zoom webinar.

    Use this tool to get a list of participants who attended a past webinar on Zoom. Ensure the webinar has concluded and allow time for participant data to process, especially for large events. Suitable for checking attendance records."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/past_webinars/{webinarId}/participants".format(  # noqa: UP032
                webinarId=webinar_id
            ),
            params=remove_none_values({
                "page_size": number_of_records_per_call,
                "next_page_token": pagination_token_for_participants,
            }),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "webinar:read:list_past_polls",
            "webinar:read:list_past_polls:admin",
            "webinar:read",
            "webinar:read:admin",
        ],
    )
)
async def get_webinar_poll_results(
    context: ToolContext,
    webinar_id: Annotated[
        str, "The ID or UUID of the webinar. Use a double-encoded UUID if it contains '/' or '//'."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listPastWebinarPollResults'."]:
    """Retrieve poll results from a past webinar.

    This tool fetches the results for polling questions from a specific past webinar. It should be used when you need detailed insights into participant responses during a webinar poll. Ensure the necessary webinar license and scopes are available."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/past_webinars/{webinarId}/polls".format(  # noqa: UP032
                webinarId=webinar_id
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "webinar:read:past_qa",
            "webinar:read",
            "webinar:read:admin",
            "webinar:read:past_qa:admin",
        ],
    )
)
async def list_webinar_qa(
    context: ToolContext,
    webinar_identifier: Annotated[
        str,
        "The ID or UUID of the webinar. If using a UUID with '/' or '//', double encode before use.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listPastWebinarQA'."]:
    """Retrieve Q&A from a past webinar on Zoom.

    This tool retrieves the questions and answers from a specific past webinar on Zoom. Useful for reviewing interactions between attendees and panelists. Requires webinar read permissions."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/past_webinars/{webinarId}/qa".format(  # noqa: UP032
                webinarId=webinar_identifier
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "webinar:read",
            "webinar:read:admin",
            "webinar:read:list_templates",
            "webinar:read:list_templates:admin",
        ],
    )
)
async def list_zoom_webinar_templates(
    context: ToolContext,
    user_identifier: Annotated[
        str, "The user's unique ID. Use 'me' for user-level apps to identify the current user."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'listWebinarTemplates'."]:
    """Retrieve a list of a user's Zoom webinar templates.

    Call this tool to obtain a list of webinar templates for a specific Zoom user. Useful when you want to view or use templates for scheduling future webinars. Requires a Pro or higher account with the Zoom Webinar plan."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/users/{userId}/webinar_templates".format(  # noqa: UP032
                userId=user_identifier
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "webinar:read",
            "webinar:read:admin",
            "webinar:read:list_webinars:admin",
            "webinar:read:list_webinars",
        ],
    )
)
async def list_zoom_webinars(
    context: ToolContext,
    user_identifier: Annotated[
        str,
        "The user's ID or email address. For user-level apps, use 'me' to refer to the authenticated user.",  # noqa: E501
    ],
    webinar_type: Annotated[
        str | None,
        "Specify the type of webinars to list. Choose 'scheduled' for unexpired, live, and upcoming scheduled webinars, or 'upcoming' for all upcoming webinars, including live ones.",  # noqa: E501
    ] = None,
    webinar_list_page_size: Annotated[
        int | None,
        "The number of webinar records to return in a single API call for the Zoom user. Adjust for pagination needs.",  # noqa: E501
    ] = None,
    next_page_token: Annotated[
        int | None, "Use this token for pagination instead of the deprecated page_number field."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'webinars'."]:
    """Retrieve all scheduled webinars for a Zoom user.

    This tool lists all the webinars scheduled by or on behalf of a webinar host in Zoom. It's useful for users or apps with webinar plans that need to manage or review upcoming webinars. The tool returns only unexpired webinars and requires a Pro or higher plan with the webinar add-on."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/users/{userId}/webinars".format(userId=user_identifier),  # noqa: UP032
            params=remove_none_values({
                "type": webinar_type,
                "page_size": webinar_list_page_size,
                "page_number": next_page_token,
            }),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "webinar:read:webinar:admin",
            "webinar:read",
            "webinar:read:admin",
            "webinar:read:webinar",
        ],
    )
)
async def get_zoom_webinar_details(
    context: ToolContext,
    webinar_id: Annotated[
        str,
        "The Zoom webinar's ID or universally unique identifier (UUID) to fetch the specific webinar details.",  # noqa: E501
    ],
    recurring_webinar_occurrence_id: Annotated[
        str | None,
        "Unique identifier for a specific occurrence of a recurring webinar. Used to retrieve details for that occurrence.",  # noqa: E501
    ] = None,
    show_previous_occurrences: Annotated[
        bool | None,
        "Set to true to view details of all previous occurrences of a recurring webinar.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'webinar'."]:
    """Retrieve details for a scheduled Zoom webinar.

    This tool fetches detailed information about a scheduled Zoom webinar. It should be called when information about a specific webinar is needed. Requires a Pro or higher plan with a Webinar add-on."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/webinars/{webinarId}".format(webinarId=webinar_id),  # noqa: UP032
            params=remove_none_values({
                "occurrence_id": recurring_webinar_occurrence_id,
                "show_previous_occurrences": show_previous_occurrences,
            }),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "webinar:write:admin",
            "webinar:delete:webinar",
            "webinar:write",
            "webinar:delete:webinar:admin",
        ],
    )
)
async def delete_webinar(
    context: ToolContext,
    webinar_id: Annotated[
        int,
        "The unique identifier for the Zoom webinar to be deleted. This is required to specify which webinar should be removed.",  # noqa: E501
    ],
    webinar_occurrence_id: Annotated[
        str | None,
        "The ID of the specific webinar occurrence to delete. Required for webinars with multiple occurrences.",  # noqa: E501
    ] = None,
    send_cancellation_notifications: Annotated[
        bool | None,
        "Set to true to email panelists and registrants about webinar cancellation. Defaults to false.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'webinarDelete'."]:
    """Delete a Zoom webinar.

    Use this tool to delete a webinar on Zoom. Requires a Pro or higher plan with the webinar add-on. The necessary OAuth scopes must be authorized, and it adheres to a LIGHT rate limit."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/webinars/{webinarId}".format(webinarId=webinar_id),  # noqa: UP032
            params=remove_none_values({
                "occurrence_id": webinar_occurrence_id,
                "cancel_webinar_reminder": send_cancellation_notifications,
            }),
            method="DELETE",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "webinar:read:branding",
            "webinar:read",
            "webinar:read:branding:admin",
            "webinar:read:admin",
        ],
    )
)
async def get_webinar_branding_info(
    context: ToolContext,
    webinar_id: Annotated[
        int,
        "The unique ID of the webinar for which to retrieve session branding information. This is required and must be a valid integer.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getWebinarBranding'."]:
    """Retrieve webinar session branding information.

    Use this tool to get information about a webinar's session branding, including wallpaper, virtual backgrounds, and name tags for participants such as hosts and panelists. Ensure your account has the necessary Webinar plan add-on and settings enabled."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/webinars/{webinarId}/branding".format(webinarId=webinar_id),  # noqa: UP032
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "webinar:write:admin",
            "webinar:delete:branding_name_tag",
            "webinar:delete:branding_name_tag:admin",
            "webinar:write",
        ],
    )
)
async def delete_webinar_name_tag(
    context: ToolContext,
    webinar_id: Annotated[
        int,
        "The unique identifier for the Zoom webinar from which the branding name tag should be deleted.",  # noqa: E501
    ],
    name_tag_ids: Annotated[
        str | None, "Comma-separated list of name tag IDs to delete for a webinar."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteWebinarBrandingNameTag'."]:
    """Delete a Zoom webinar's branding name tag.

    This tool deletes the session branding name tag for a specified Zoom webinar. It should be called when you want to remove an existing name tag linked to a webinar. Prerequisites include enabling the Webinar Session Branding setting and having the necessary scopes."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/webinars/{webinarId}/branding/name_tags".format(  # noqa: UP032
                webinarId=webinar_id
            ),
            params=remove_none_values({"name_tag_ids": name_tag_ids}),
            method="DELETE",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "webinar:write:admin",
            "webinar:delete:branding_virtual_background",
            "webinar:write",
            "webinar:delete:branding_virtual_background:admin",
        ],
    )
)
async def delete_webinar_virtual_background(
    context: ToolContext,
    webinar_id: Annotated[
        int,
        "The unique ID of the webinar for which the virtual background should be deleted. This ID is required.",  # noqa: E501
    ],
    virtual_background_file_ids: Annotated[
        str | None,
        "Provide a comma-separated list of virtual background file IDs to be deleted from the webinar.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteWebinarBrandingVB'."]:
    """Delete a webinar's virtual background.

    Call this tool to delete the virtual background branding of a specific webinar session on Zoom. Ensure the 'Webinar Session Branding' setting is enabled. Requires appropriate OAuth scopes such as `webinar:write` or `webinar:delete:branding_virtual_background`."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/webinars/{webinarId}/branding/virtual_backgrounds".format(  # noqa: UP032
                webinarId=webinar_id
            ),
            params=remove_none_values({"ids": virtual_background_file_ids}),
            method="DELETE",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "webinar:write:admin",
            "webinar:update:branding_virtual_background",
            "webinar:update:branding_virtual_background:admin",
            "webinar:write",
        ],
    )
)
async def set_webinar_virtual_background(
    context: ToolContext,
    webinar_id: Annotated[
        int, "The unique identifier for the webinar to update the virtual background branding."
    ],
    virtual_background_file_id: Annotated[
        str | None, "The ID of the virtual background file to update for the webinar."
    ] = None,
    set_default_virtual_background_for_all_panelists: Annotated[
        bool | None,
        "Whether to set the virtual background as the default for all panelists, including those without a current default background.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'setWebinarBrandingVB'."]:
    """Set a webinar's virtual background branding.

    This tool sets the default virtual background branding for a Zoom webinar session. It requires the 'Webinar Session Branding' setting enabled and appropriate scopes such as 'webinar:write' or 'webinar:write:admin'."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/webinars/{webinarId}/branding/virtual_backgrounds".format(  # noqa: UP032
                webinarId=webinar_id
            ),
            params=remove_none_values({
                "id": virtual_background_file_id,
                "set_default_for_all_panelists": set_default_virtual_background_for_all_panelists,
            }),
            method="PATCH",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "webinar:delete:branding_wallpaper",
            "webinar:write:admin",
            "webinar:write",
            "webinar:delete:branding_wallpaper:admin",
        ],
    )
)
async def remove_webinar_branding_wallpaper(
    context: ToolContext,
    webinar_id: Annotated[
        int, "The unique identifier of the webinar whose branding wallpaper you want to delete."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteWebinarBrandingWallpaper'."]:
    """Remove a webinar's branding wallpaper file.

    This tool deletes the branding wallpaper file from a specified webinar. It should be called when you want to update or remove the session branding for a webinar. Make sure the Webinar Session Branding setting is enabled and the correct scopes are authorized."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/webinars/{webinarId}/branding/wallpaper".format(  # noqa: UP032
                webinarId=webinar_id
            ),
            method="DELETE",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "webinar:read:live_streaming_token",
            "webinar_token:read:admin:live_streaming",
            "webinar_token:read:live_streaming",
            "webinar:read:live_streaming_token:admin",
        ],
    )
)
async def get_webinar_live_streaming_join_token(
    context: ToolContext,
    webinar_id: Annotated[
        int,
        "The unique identifier for the webinar. This is required to retrieve the live streaming join token.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'webinarLiveStreamingJoinToken'."]:
    """Retrieve a Zoom webinar's join token for live streaming.

    Use this tool to get the archive token needed for live streaming a Zoom webinar. It allows a recording bot to connect to a webinar and stream automatically. Requires a Pro plan with a Webinar add-on and the relevant Zoom settings enabled."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/webinars/{webinarId}/jointoken/live_streaming".format(  # noqa: UP032
                webinarId=webinar_id
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "webinar_token:read:admin:local_archiving",
            "webinar:read:local_archiving_token:admin",
        ],
    )
)
async def get_webinar_archive_token(
    context: ToolContext,
    webinar_id: Annotated[
        int,
        "The unique identifier for the webinar whose archive token is to be retrieved. This ID is necessary to obtain access to the webinar's raw media streams.",  # noqa: E501
    ],
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'webinarLocalArchivingArchiveToken'."
]:
    """Get a webinar's archive token for local archiving.

    Use this tool to obtain a token that allows local archiving of a Zoom webinar. This is essential for applications or bots needing real-time access to a webinar's raw audio and video streams."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/webinars/{webinarId}/jointoken/local_archiving".format(  # noqa: UP032
                webinarId=webinar_id
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "webinar_token:read:admin:local_recording",
            "webinar:read:local_recording_token",
            "webinar_token:read:local_recording",
            "webinar:read:local_recording_token:admin",
        ],
    )
)
async def get_zoom_webinar_local_recording_token(
    context: ToolContext,
    webinar_id: Annotated[
        int,
        "The unique identifier for the Zoom webinar to retrieve the join token for local recording.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'webinarLocalRecordingJoinToken'."]:
    """Retrieve Zoom webinar join token for local recording.

    Fetches a join token to enable a recording bot to connect and locally record a Zoom webinar using the Zoom Meeting SDK. This is applicable for users with a Pro or higher plan with a Webinar add-on and local recording enabled."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/webinars/{webinarId}/jointoken/local_recording".format(  # noqa: UP032
                webinarId=webinar_id
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "webinar:read:livestream",
            "webinar:read:livestream:admin",
            "webinar:read",
            "webinar:read:admin",
        ],
    )
)
async def get_webinar_livestream_details(
    context: ToolContext,
    webinar_unique_id: Annotated[
        str, "The unique identifier for the webinar to retrieve live stream details."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getWebinarLiveStreamDetails'."]:
    """Retrieve live stream details for a Zoom webinar.

    Fetches the live stream configuration details of a specified Zoom webinar, including Stream URL, Stream Key, and Page URL. Requires a Pro or higher plan with the webinar add-on and pre-configured streaming settings."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/webinars/{webinarId}/livestream".format(  # noqa: UP032
                webinarId=webinar_unique_id
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "webinar:read:list_panelists:admin",
            "webinar:read",
            "webinar:read:admin",
            "webinar:read:list_panelists",
        ],
    )
)
async def list_zoom_webinar_panelists(
    context: ToolContext,
    webinar_id: Annotated[int, "The unique identifier for the Zoom webinar."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'webinarPanelists'."]:
    """Retrieve a list of panelists for a specific Zoom webinar.

    Fetches all panelists associated with a particular Zoom webinar. Useful for viewing panelists who have access to enhanced capabilities like video sharing and screen annotation. Requires a Pro or higher plan with the Webinar Add-on."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/webinars/{webinarId}/panelists".format(  # noqa: UP032
                webinarId=webinar_id
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "webinar:delete:panelist",
            "webinar:write:admin",
            "webinar:delete:panelist:admin",
            "webinar:write",
        ],
    )
)
async def remove_webinar_panelists(
    context: ToolContext,
    webinar_id: Annotated[
        int,
        "The unique identifier for the webinar from which you want to remove all panelists. This should be an integer.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'webinarPanelistsDelete'."]:
    """Remove all panelists from a specified Zoom webinar.

    Use this tool to remove all panelists from a Zoom webinar. Ideal for managing webinar participants efficiently. Requires a Pro or higher plan with the webinar add-on."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/webinars/{webinarId}/panelists".format(  # noqa: UP032
                webinarId=webinar_id
            ),
            method="DELETE",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "webinar:delete:panelist",
            "webinar:write:admin",
            "webinar:delete:panelist:admin",
            "webinar:write",
        ],
    )
)
async def remove_webinar_panelist(
    context: ToolContext,
    webinar_id: Annotated[
        int,
        "The unique identifier for the webinar from which the panelist will be removed. This should be an integer value.",  # noqa: E501
    ],
    panelist_identifier: Annotated[
        str,
        "The ID or email of the panelist to remove from the webinar. Obtain from the List Panelists API.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'webinarPanelistDelete'."]:
    """Remove a panelist from a Zoom webinar.

    This tool removes a specified panelist from a Zoom webinar. It requires a Pro or higher plan with the webinar add-on. The panelistId must be obtained from the List Panelists API."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/webinars/{webinarId}/panelists/{panelistId}".format(  # noqa: UP032
                webinarId=webinar_id, panelistId=panelist_identifier
            ),
            method="DELETE",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "webinar:read:list_polls",
            "webinar:read",
            "webinar:read:list_polls:admin",
            "webinar:read:admin",
        ],
    )
)
async def list_webinar_polls_zoom(
    context: ToolContext,
    webinar_id: Annotated[int, "The ID of the Zoom webinar for which to retrieve polls."],
    query_anonymous_polls: Annotated[
        bool | None,
        "Set to true to query polls with the Anonymous option enabled. Set to false to exclude them.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'webinarPolls'."]:
    """Retrieve all polls from a Zoom webinar.

    Use this tool to get a list of all polls associated with a specific Zoom webinar. This requires a Pro or higher plan with a Webinar add-on. Ensure proper authorization scopes are in place."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/webinars/{webinarId}/polls".format(webinarId=webinar_id),  # noqa: UP032
            params=remove_none_values({"anonymous": query_anonymous_polls}),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "webinar:read:poll:admin",
            "webinar:read",
            "webinar:read:poll",
            "webinar:read:admin",
        ],
    )
)
async def get_webinar_poll_details(
    context: ToolContext,
    webinar_id: Annotated[
        int,
        "The unique identifier of the webinar for which the poll details are being requested. This is required to fetch the poll data.",  # noqa: E501
    ],
    poll_id: Annotated[
        str,
        "The unique identifier for the specific webinar poll. This is required to fetch the poll details.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'webinarPollGet'."]:
    """Fetches details of a webinar poll from Zoom.

    Use this tool to retrieve detailed information about a specific poll in a Zoom webinar. It requires a Pro or higher plan with a Webinar add-on. Ensure the necessary OAuth scopes are set for access."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/webinars/{webinarId}/polls/{pollId}".format(  # noqa: UP032
                webinarId=webinar_id, pollId=poll_id
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "webinar:delete:poll:admin",
            "webinar:write:admin",
            "webinar:delete:poll",
            "webinar:write",
        ],
    )
)
async def delete_webinar_poll(
    context: ToolContext,
    webinar_id: Annotated[
        int, "The unique identifier for the webinar from which the poll should be deleted."
    ],
    poll_id: Annotated[str, "The unique identifier for the poll to be deleted from the webinar."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'webinarPollDelete'."]:
    """Delete a poll from a specific webinar on Zoom.

    Use this tool to delete a poll from a Zoom webinar. Requires a Pro or higher plan with a Webinar plan add-on. Ensure you have the necessary OAuth scopes: `webinar:write:admin`, `webinar:write`, `webinar:delete:poll`, or `webinar:delete:poll:admin`. This operation has a LIGHT rate limit."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/webinars/{webinarId}/polls/{pollId}".format(  # noqa: UP032
                webinarId=webinar_id, pollId=poll_id
            ),
            method="DELETE",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "webinar:read",
            "webinar:read:list_registrants:admin",
            "webinar:read:admin",
            "webinar:read:list_registrants",
        ],
    )
)
async def list_zoom_webinar_registrants(
    context: ToolContext,
    webinar_id: Annotated[
        int,
        "The unique ID of the webinar for which registrants are being retrieved. This is required for the request.",  # noqa: E501
    ],
    webinar_occurrence_id: Annotated[
        str | None,
        "The unique identifier for a specific occurrence of the webinar. Use this ID to specify which instance of a recurring webinar you are querying.",  # noqa: E501
    ] = None,
    registrant_status: Annotated[
        str | None,
        "Filter registrants by status: 'pending' for those awaiting approval, 'approved' for accepted registrants, or 'denied' for rejected applications.",  # noqa: E501
    ] = None,
    registrants_tracking_source_id: Annotated[
        str | None,
        "The tracking source ID for webinar registrants, indicating the registration page location.",  # noqa: E501
    ] = None,
    number_of_records_per_call: Annotated[
        int | None,
        "The number of registrant records to return within a single API call. This helps control the size of the response.",  # noqa: E501
    ] = None,
    deprecated_page_number: Annotated[
        int | None,
        "Deprecated. This field will be deprecated and is no longer supported in future releases. Use 'next_page_token' for pagination instead.",  # noqa: E501
    ] = None,
    pagination_next_page_token: Annotated[
        str | None,
        "Token for paginating through webinar registrant results when the available set exceeds the current page size. Expires in 15 minutes.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'webinarRegistrants'."]:
    """Retrieve a list of registrants for a specified Zoom webinar.

    Call this tool to obtain a list of all users who have registered for a specific Zoom webinar. This is useful for managing webinar attendees. Requires a Pro or higher plan with a Webinar add-on and appropriate OAuth scopes."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/webinars/{webinarId}/registrants".format(  # noqa: UP032
                webinarId=webinar_id
            ),
            params=remove_none_values({
                "occurrence_id": webinar_occurrence_id,
                "status": registrant_status,
                "tracking_source_id": registrants_tracking_source_id,
                "page_size": number_of_records_per_call,
                "page_number": deprecated_page_number,
                "next_page_token": pagination_next_page_token,
            }),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "webinar:read:list_registration_questions",
            "webinar:read:list_registration_questions:admin",
            "webinar:read",
            "webinar:read:admin",
        ],
    )
)
async def get_webinar_registration_questions(
    context: ToolContext,
    webinar_id: Annotated[
        int,
        "The unique identifier for the webinar. It is required to retrieve the registration questions.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'webinarRegistrantsQuestionsGet'."]:
    """Retrieve registration questions for webinar attendees.

    Use this tool to get a list of questions and fields users need to answer when registering for a webinar. This is applicable for webinars set up with registration requirements. Ensure you have a Pro or higher plan with the webinar add-on to access this information."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/webinars/{webinarId}/registrants/questions".format(  # noqa: UP032
                webinarId=webinar_id
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "webinar:read",
            "webinar:read:registrant",
            "webinar:read:admin",
            "webinar:read:registrant:admin",
        ],
    )
)
async def get_webinar_registrant_details(
    context: ToolContext,
    webinar_id: Annotated[
        int, "The unique ID of the webinar for which registrant details are needed."
    ],
    registrant_id: Annotated[
        str,
        "The unique identifier for the webinar registrant. Required to fetch the registrant's details.",  # noqa: E501
    ],
    webinar_occurrence_id: Annotated[
        str | None,
        "The unique identifier for a specific occurrence of the webinar to fetch registrant details.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'webinarRegistrantGet'."]:
    """Retrieve details for a specific Zoom webinar registrant.

    This tool fetches information about a specific user registered for a Zoom webinar. It is useful for hosts or admins to manage and verify registrant details, requiring a Zoom account with a webinar plan."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/webinars/{webinarId}/registrants/{registrantId}".format(  # noqa: UP032
                webinarId=webinar_id, registrantId=registrant_id
            ),
            params=remove_none_values({"occurrence_id": webinar_occurrence_id}),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "webinar:write:admin",
            "webinar:delete:registrant",
            "webinar:write",
            "webinar:delete:registrant:admin",
        ],
    )
)
async def remove_webinar_registrant(
    context: ToolContext,
    webinar_id: Annotated[
        int,
        "The unique identifier for the specific Zoom webinar from which the registrant will be removed.",  # noqa: E501
    ],
    registrant_id: Annotated[
        str, "The unique identifier of the registrant to be removed from the webinar."
    ],
    webinar_occurrence_id: Annotated[
        str | None, "The unique identifier for the specific webinar occurrence."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteWebinarRegistrant'."]:
    """Remove a registrant from a Zoom webinar.

    This tool is used to delete a registrant from a specific Zoom webinar. It requires a Pro or higher plan with a Webinar add-on. Appropriate scopes are necessary for execution."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/webinars/{webinarId}/registrants/{registrantId}".format(  # noqa: UP032
                webinarId=webinar_id, registrantId=registrant_id
            ),
            params=remove_none_values({"occurrence_id": webinar_occurrence_id}),
            method="DELETE",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "webinar:read:survey",
            "webinar:read",
            "webinar:read:admin",
            "webinar:read:survey:admin",
        ],
    )
)
async def get_webinar_survey_info(
    context: ToolContext,
    webinar_id: Annotated[
        int, "The unique ID of the Zoom webinar for which you want to retrieve survey details."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'webinarSurveyGet'."]:
    """Retrieve details about a Zoom webinar survey.

    This tool retrieves information about a specific webinar survey on Zoom. It requires a Pro or higher plan with the Webinar add-on and the Webinar Survey feature enabled. It's useful for obtaining survey data post-webinar, and requires appropriate authorization scopes to access the information."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/webinars/{webinarId}/survey".format(webinarId=webinar_id),  # noqa: UP032
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "webinar:write:admin",
            "webinar:delete:survey:admin",
            "webinar:write",
            "webinar:delete:survey",
        ],
    )
)
async def delete_zoom_webinar_survey(
    context: ToolContext,
    webinar_id: Annotated[
        int,
        "The unique identifier for the webinar to delete its survey. This must be a valid integer ID from Zoom.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'webinarSurveyDelete'."]:
    """Delete a Zoom webinar survey.

    Use this tool to delete a specific survey from a Zoom webinar. Requires a Pro or higher plan with the Webinar Add-on and the Webinar Survey feature enabled. Appropriate OAuth scopes are needed for authorization."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/webinars/{webinarId}/survey".format(webinarId=webinar_id),  # noqa: UP032
            method="DELETE",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "webinar:read:token:admin",
            "webinar:read",
            "webinar:read:admin",
            "webinar:read:token",
        ],
    )
)
async def get_webinar_caption_token(
    context: ToolContext,
    webinar_id: Annotated[
        int, "The ID of the webinar for which the closed caption token is requested."
    ],
    webinar_token_type: Annotated[
        str | None,
        "The type of token needed for the webinar. Only 'closed_caption_token' is supported for third-party closed caption API access. Defaults to 'closed_caption_token'.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'webinarToken'."]:
    """Retrieve a closed caption token for a Zoom webinar.

    Use this tool to get a closed caption token URL for a Zoom webinar, enabling third-party closed captioning services. Requires a Pro or higher plan with the Webinar add-on and relevant settings enabled."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/webinars/{webinarId}/token".format(webinarId=webinar_id),  # noqa: UP032
            params=remove_none_values({"type": webinar_token_type}),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}


@tool(
    requires_auth=OAuth2(
        id="arcade-zoom",
        scopes=[
            "webinar:read:list_tracking_sources",
            "webinar:read:list_tracking_sources:admin",
            "webinar:read",
            "webinar:read:admin",
        ],
    )
)
async def get_webinar_tracking_sources(
    context: ToolContext,
    webinar_id: Annotated[
        int,
        "The unique identifier of the Zoom webinar for which you want to list tracking sources. Ensure the webinar has registration enabled.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getTrackingSources'."]:
    """List tracking sources for a Zoom webinar.

    Use this tool to retrieve information on all tracking sources for a specific Zoom webinar, helping to analyze registrant origins from various platforms. Requires webinar registration to be enabled and a proper webinar license."""  # noqa: E501
    async with httpx.AsyncClient() as client:
        response = await client.request(
            url="https://api.zoom.us/v2/webinars/{webinarId}/tracking_sources".format(  # noqa: UP032
                webinarId=webinar_id
            ),
            method="GET",
            headers=remove_none_values({
                "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                    authorization=context.get_auth_token_or_empty()
                )
            }),
        )
        response.raise_for_status()
        try:
            return {"response_json": response.json()}
        except Exception:
            return {"response_text": response.text}
