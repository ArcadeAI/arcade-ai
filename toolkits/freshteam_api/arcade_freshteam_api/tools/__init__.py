"""Arcade Starter Tools for freshteam

DO NOT EDIT THIS MODULE DIRECTLY.

THIS MODULE WAS AUTO-GENERATED BY TRANSPILING THE API STARTER TOOL JSON DEFINITIONS
IN THE ../wrapper_tools DIRECTORY INTO PYTHON CODE. ANY CHANGES TO THIS MODULE WILL
BE OVERWRITTEN BY THE TRANSPILER.
"""

import asyncio
import json
import jsonschema
from enum import Enum
from typing import Annotated, Any

import httpx

from arcade_tdk import tool, ToolContext
from arcade_tdk.errors import RetryableToolError

from .request_body_schemas import REQUEST_BODY_SCHEMAS

# Retry configuration
INITIAL_RETRY_DELAY = 0.5  # seconds

HTTP_CLIENT = httpx.AsyncClient(
    timeout=httpx.Timeout(60.0, connect=10.0),
    limits=httpx.Limits(max_keepalive_connections=20, max_connections=100),
    transport=httpx.AsyncHTTPTransport(retries=3),
    http2=True,
    follow_redirects=True,
)


class ToolMode(str, Enum):
    """Mode for tools with complex request bodies."""

    GET_REQUEST_SCHEMA = "get_request_schema"
    EXECUTE = "execute"


def remove_none_values(data: dict[str, Any]) -> dict[str, Any]:
    return {k: v for k, v in data.items() if v is not None}


async def make_request(
    url: str,
    method: str,
    params: dict[str, Any] | None = None,
    headers: dict[str, Any] | None = None,
    content: str | None = None,
    data: dict[str, Any] | None = None,
    auth: tuple[str, str] | None = None,
    max_retries: int = 3,
) -> httpx.Response:
    """Make an HTTP request with retry logic for 5xx server errors."""
    for attempt in range(max_retries):
        try:
            response = await HTTP_CLIENT.request(
                url=url,
                auth=auth,
                method=method,
                params=params,
                headers=headers,
                content=content,
            )
            response.raise_for_status()
        except httpx.HTTPStatusError as e:
            # Only retry on 5xx server errors
            if e.response.status_code >= 500 and attempt < max_retries - 1:
                # Exponential backoff: 0.5s, 1s, 2s
                await asyncio.sleep(INITIAL_RETRY_DELAY * (2**attempt))
                continue
            # Re-raise for 4xx errors or if max retries reached
            raise
        except httpx.RequestError as e:
            # Don't retry request errors (network issues are handled by transport)
            raise
        else:
            return response

    # This should never be reached, but satisfies type checker
    raise httpx.RequestError("Max retries exceeded")  # noqa: TRY003


async def make_request_with_schema_validation(
    url: str,
    method: str,
    request_data: dict[str, Any],
    schema: dict[str, Any],
    params: dict[str, Any] | None = None,
    headers: dict[str, Any] | None = None,
    max_retries: int = 3,
) -> httpx.Response:
    """Make an HTTP request with schema validation on format errors."""
    try:
        response = await make_request(
            url=url,
            method=method,
            params=params,
            headers=headers,
            content=json.dumps(request_data),
            max_retries=max_retries,
        )
        return response
    except httpx.HTTPStatusError as e:
        # Only provide schema validation for format-related errors
        if e.response.status_code in (400, 422):
            # Run validation to provide additional context
            is_valid, validation_error = validate_json_against_schema(request_data, schema)

            api_error_details = f"API returned {e.response.status_code}: {e.response.text}"

            if not is_valid:
                # Schema validation found issues - additional context
                additional_context = (
                    f"{api_error_details}\n\n"
                    f"Schema validation found the following issues:\n"
                    f"{validation_error}"
                )
            else:
                # Schema validation passed - just show API error
                additional_context = api_error_details

            raise RetryableToolError(
                message=(f"API request failed with validation error: {e.response.status_code}"),
                developer_message=api_error_details,
                additional_prompt_content=additional_context,
            ) from e
        else:
            # For non-validation errors, re-raise as-is
            raise


def validate_json_against_schema(
    json_data: dict[str, Any], schema: dict[str, Any]
) -> tuple[bool, str | None]:
    """Validate JSON data against an OpenAPI/JSON Schema.

    This provides full JSON Schema Draft 7 validation including:
    - Required fields, types, enums
    - Pattern validation (regex)
    - Format validation (email, uuid, date-time, etc.)
    - Min/max length and values
    - oneOf, anyOf, allOf
    - And all other JSON Schema features

    Args:
        json_data: The JSON data to validate
        schema: The JSON Schema to validate against

    Returns:
        Tuple of (is_valid, error_messages). If valid, error_messages is None.
        If invalid, error_messages contains all validation errors.
    """
    try:
        validator = jsonschema.Draft7Validator(
            schema, format_checker=jsonschema.Draft7Validator.FORMAT_CHECKER
        )
        # Collect ALL validation errors
        errors = list(validator.iter_errors(json_data))
        if errors:
            # Format all errors with their paths
            error_messages = []
            for error in errors:
                error_path = ".".join(str(p) for p in error.path) if error.path else "root"
                error_messages.append(f"{error.message} at {error_path}")
            # Join all errors with newlines
            return False, "\n".join(error_messages)
        else:
            return True, None
    except jsonschema.SchemaError as e:
        return False, f"Invalid schema: {e.message}"
    except Exception as e:
        return False, f"Validation error: {e!s}"


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def list_active_employees(
    context: ToolContext,
    employee_status_keys: Annotated[
        list[str] | None,
        "An array of status keys to filter employees by. For example, use 'active', 'inactive', etc.",  # noqa: E501
    ] = None,
    filter_by_first_name: Annotated[
        str | None,
        "Filter active employees by their first name. Provide the first name to query specific users.",  # noqa: E501
    ] = None,
    user_last_name: Annotated[
        str | None, "The last name of users to filter the employee directory search results."
    ] = None,
    query_by_personal_email: Annotated[
        str | None, "The personal email address used to filter employees."
    ] = None,
    official_email_to_query: Annotated[
        str | None, "Official email address of the employee to be queried."
    ] = None,
    employee_type: Annotated[
        str | None,
        "Specify the type of employee to query, such as full-time, part-time, or contractor.",
    ] = None,
    department_ids: Annotated[
        list[int] | None,
        "An array of department IDs to filter the employees by. Each ID should be an integer.",
    ] = None,
    business_unit_ids: Annotated[
        list[int] | None, "Identifiers of user business units to query, as a list of integers."
    ] = None,
    location_ids: Annotated[
        list[int] | None, "An array of integer IDs representing user locations to query."
    ] = None,
    reporting_manager_ids: Annotated[
        list[int] | None,
        "A list of reporting manager IDs to filter employees by. Each ID should be an integer.",
    ] = None,
    employee_id: Annotated[
        str | None, "Specify the Employee ID to query information about a particular employee."
    ] = None,
    updated_since_timestamp: Annotated[
        str | None,
        "A timestamp to filter employees updated since a specific date. Format: YYYY-MM-DD.",
    ] = None,
    page_number: Annotated[
        int | None, "The page number to fetch in the list of active employees."
    ] = None,
    sort_by: Annotated[
        str | None,
        "Specify the attribute to sort the employee list by, such as first_name, last_name, or employee_id.",  # noqa: E501
    ] = None,
    order_direction: Annotated[
        str | None, "Determines the order of sorting: 'asc' for ascending, 'desc' for descending."
    ] = None,
    include_draft_employees: Annotated[
        bool | None, "Include draft employees in the results when set to true."
    ] = None,
    include_deleted_users: Annotated[
        bool | None, "Set to True to include deleted users in the results."
    ] = None,
    include_terminated: Annotated[
        bool | None, "Set to true to include terminated employees in the results."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_employees'."]:
    """Retrieve a list of active employees from the directory.

    This tool is used to obtain a list of all currently active employees from the directory. It is useful for getting up-to-date employee information in situations such as team management and organizational planning."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/employees",
        method="GET",
        params=remove_none_values({
            "status": employee_status_keys,
            "first_name": filter_by_first_name,
            "last_name": user_last_name,
            "personal_email": query_by_personal_email,
            "official_email": official_email_to_query,
            "employee_type": employee_type,
            "department": department_ids,
            "business_unit": business_unit_ids,
            "location": location_ids,
            "reporting_manager": reporting_manager_ids,
            "employee_id": employee_id,
            "updated_since": updated_since_timestamp,
            "draft": include_draft_employees,
            "deleted": include_deleted_users,
            "terminated": include_terminated,
            "page": page_number,
            "sort": sort_by,
            "sort_type": order_direction,
        }),
        headers=remove_none_values({
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION")
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def add_new_employee(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'create_employee'."]:
    """Add a new employee to the system.

    Use this tool to add a new employee to the Freshteam system. This is useful when onboarding new staff.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["ADDNEWEMPLOYEE_REQUEST_BODY_SCHEMA"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n"
                + json.dumps(REQUEST_BODY_SCHEMAS["ADDNEWEMPLOYEE_REQUEST_BODY_SCHEMA"], indent=2)
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n"
                + json.dumps(REQUEST_BODY_SCHEMAS["ADDNEWEMPLOYEE_REQUEST_BODY_SCHEMA"], indent=2)
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://adityasharma2519.freshteam.com/api/employees",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["ADDNEWEMPLOYEE_REQUEST_BODY_SCHEMA"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION"),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def get_employee_details(
    context: ToolContext,
    employee_id: Annotated[
        int,
        "The unique identifier for the employee whose details are requested. This should be an integer.",  # noqa: E501
    ],
    additional_properties_to_include: Annotated[
        list[str] | None,
        "List of additional properties to include in the employee details response.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_employee'."]:
    """Retrieve details of a specific employee by ID.

    Use this tool to get detailed information about an employee in your Freshteam account. It requires the employee ID and returns various details related to the employee."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/employees/{id}".format(id=employee_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({"include": additional_properties_to_include}),
        headers=remove_none_values({
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION")
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def update_employee_info(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    employee_id: Annotated[
        int | None,
        "The unique identifier for the employee whose information is being updated.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'update_employee'."]:
    """Updates an employee's information in the system.

    This tool is used to update the details of an existing employee in the Freshteam system. Call this tool when you need to modify an employee's information such as name, position, or contact details.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPDATEEMPLOYEEINFO_REQUEST_BODY_SCHEMA"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not employee_id:
        missing_params.append(("employee_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{{p[0]}} ({{p[1]}})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {{param_names}}",
            developer_message=(f"Required parameters validation failed: {{param_details}}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{{param_details}}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n"
                + json.dumps(
                    REQUEST_BODY_SCHEMAS["UPDATEEMPLOYEEINFO_REQUEST_BODY_SCHEMA"], indent=2
                )
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n"
                + json.dumps(
                    REQUEST_BODY_SCHEMAS["UPDATEEMPLOYEEINFO_REQUEST_BODY_SCHEMA"], indent=2
                )
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://adityasharma2519.freshteam.com/api/employees/{id}".format(id=employee_id),  # noqa: UP032
        method="PUT",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPDATEEMPLOYEEINFO_REQUEST_BODY_SCHEMA"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION"),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def send_invite_email(
    context: ToolContext,
    employee_id: Annotated[int, "The ID of the employee to whom the invite email will be sent."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'send_invite'."]:
    """Sends an invite email to an employee.

    Use this tool to send an invitation email to a specified employee by their ID. Suitable for onboarding processes or when granting system access to employees."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/employees/{id}/send_invite".format(  # noqa: UP032
            id=employee_id
        ),
        method="PUT",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION")
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def fetch_new_hires(
    context: ToolContext,
    hire_status_keys: Annotated[
        list[str] | None,
        "List of status keys to filter the new hires. Each key should be a string representing a status type.",  # noqa: E501
    ] = None,
    query_first_name: Annotated[
        str | None, "Specify the first name of users to query for new hires."
    ] = None,
    filter_by_last_name: Annotated[
        str | None, "Specify the last name of users to filter the new hires list."
    ] = None,
    personal_email: Annotated[
        str | None, "The personal email address of the user to query for new hires."
    ] = None,
    official_email_to_query: Annotated[
        str | None, "Filter new hires by their official email address."
    ] = None,
    employee_type: Annotated[
        str | None,
        "Employee type to filter the query results (e.g., full-time, part-time, contract).",
    ] = None,
    department_ids: Annotated[
        list[int] | None,
        "An array of department IDs to query for new hires. Each ID should be an integer.",
    ] = None,
    business_unit_ids: Annotated[
        list[int] | None, "Array of integer IDs representing the business units to query."
    ] = None,
    user_location_ids: Annotated[
        list[int] | None, "An array of location IDs to filter new hires by their location."
    ] = None,
    reporting_manager_ids: Annotated[
        list[int] | None,
        "List of reporting manager IDs to filter users by their reporting manager.",
    ] = None,
    employee_id_to_query: Annotated[
        str | None, "Specify the Employee ID to filter the query for specific new hires."
    ] = None,
    updated_since_date: Annotated[
        str | None,
        "The date from which to retrieve updates about new hires. Use YYYY-MM-DD format.",
    ] = None,
    joining_date: Annotated[
        str | None, "Date when the employee joined. Format: YYYY-MM-DD."
    ] = None,
    page_number: Annotated[
        int | None, "The page number to retrieve in the list of new hires."
    ] = None,
    sort_by: Annotated[
        str | None,
        "Specify the field to sort the list of new hires. Options: first_name, last_name, employee_id, joining_date.",  # noqa: E501
    ] = None,
    sort_order: Annotated[
        str | None,
        "Specifies the order of sorting the new hires list. Use 'asc' for ascending or 'desc' for descending.",  # noqa: E501
    ] = None,
    draft_status: Annotated[bool | None, "Set to true to retrieve users with draft status."] = None,
    filter_deleted_users: Annotated[
        bool | None,
        "Specify if the response should exclude users marked as deleted. Use true to include deleted users and false to exclude them.",  # noqa: E501
    ] = None,
    filter_terminated: Annotated[
        bool | None,
        "Boolean to include hires based on termination status. True includes terminated hires.",
    ] = None,
    include_no_show: Annotated[
        bool | None, "Set to true to include employees marked as 'no show'; false to exclude them."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_new_hires'."]:
    """Fetches a list of newly hired employees.

    Use this tool to retrieve information about employees who have been recently hired. Ideal for keeping track of new team members and onboarding processes."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/new_hires",
        method="GET",
        params=remove_none_values({
            "status": hire_status_keys,
            "first_name": query_first_name,
            "last_name": filter_by_last_name,
            "personal_email": personal_email,
            "official_email": official_email_to_query,
            "employee_type": employee_type,
            "department": department_ids,
            "business_unit": business_unit_ids,
            "location": user_location_ids,
            "reporting_manager": reporting_manager_ids,
            "employee_id": employee_id_to_query,
            "updated_since": updated_since_date,
            "draft": draft_status,
            "deleted": filter_deleted_users,
            "terminated": filter_terminated,
            "no_show": include_no_show,
            "joining_date": joining_date,
            "page": page_number,
            "sort": sort_by,
            "sort_type": sort_order,
        }),
        headers=remove_none_values({
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION")
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def create_new_hire(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'create_new_hire'."]:
    """Create a new hire in Freshteam.

    This tool creates a new hire record in the Freshteam system. It should be called when a new employee needs to be added to the Freshteam database, ensuring their details are captured in the HR management system.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["CREATENEWHIRE_REQUEST_BODY_SCHEMA"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n"
                + json.dumps(REQUEST_BODY_SCHEMAS["CREATENEWHIRE_REQUEST_BODY_SCHEMA"], indent=2)
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n"
                + json.dumps(REQUEST_BODY_SCHEMAS["CREATENEWHIRE_REQUEST_BODY_SCHEMA"], indent=2)
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://adityasharma2519.freshteam.com/api/new_hires",
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["CREATENEWHIRE_REQUEST_BODY_SCHEMA"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION"),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def get_new_hire_details(
    context: ToolContext,
    new_hire_id: Annotated[int, "The unique identifier of the new hire to retrieve details for."],
    additional_properties: Annotated[
        list[str] | None, "List of additional properties to include in the response for a new hire."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_new_hire'."]:
    """Retrieve details of a specific new hire.

    Call this tool to obtain information about a particular new hire in the Freshteam account using their unique ID."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/new_hires/{id}".format(id=new_hire_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({"include": additional_properties}),
        headers=remove_none_values({
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION")
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def update_new_hire_info(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    new_hire_id: Annotated[
        int | None,
        "The unique identifier of the new hire to update.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'update_new_hire'."]:
    """Update information for a new hire.

    This tool updates the details of a new hire based on the provided ID. Use this tool to modify the information for employees who have recently joined.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["UPDATENEWHIREINFO_REQUEST_BODY_SCHEMA"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not new_hire_id:
        missing_params.append(("new_hire_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{{p[0]}} ({{p[1]}})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {{param_names}}",
            developer_message=(f"Required parameters validation failed: {{param_details}}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{{param_details}}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n"
                + json.dumps(
                    REQUEST_BODY_SCHEMAS["UPDATENEWHIREINFO_REQUEST_BODY_SCHEMA"], indent=2
                )
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n"
                + json.dumps(
                    REQUEST_BODY_SCHEMAS["UPDATENEWHIREINFO_REQUEST_BODY_SCHEMA"], indent=2
                )
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://adityasharma2519.freshteam.com/api/new_hires/{id}".format(id=new_hire_id),  # noqa: UP032
        method="PUT",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPDATENEWHIREINFO_REQUEST_BODY_SCHEMA"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION"),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def list_account_teams(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_teams'."]:
    """Retrieve a list of teams from the account.

    Use this tool to get a list of all teams associated with the account in Freshteam. It provides essential information about each team."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/teams",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION")
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def get_team_details(
    context: ToolContext,
    team_id: Annotated[
        int, "The unique identifier for the team whose details are to be retrieved."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_team'."]:
    """Retrieve details of a specific team by ID.

    Use this tool to fetch detailed information about a specific team within your Freshteam account by providing the team's ID."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/teams/{id}".format(id=team_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION")
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def list_business_units(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_business_units'."]:
    """Retrieve the list of business units in the account.

    Use this tool to get a list of all business units available in the account. This can be helpful for managing and understanding the organizational structure."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/business_units",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION")
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def get_business_unit_details(
    context: ToolContext,
    business_unit_id: Annotated[int, "The identifier for the business unit to retrieve details."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_business_unit'."]:
    """Fetch details of a specific business unit.

    Use this tool to obtain information about a particular business unit by providing its ID. This is helpful for accessing unit-specific data within an account."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/business_units/{id}".format(  # noqa: UP032
            id=business_unit_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION")
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def get_account_branches(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_branches'."]:
    """Retrieve a list of branch locations in the account.

    Use this tool to get information about all the branch locations associated with an account. It should be called when you need details about branch locations."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/branches",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION")
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def get_location_details(
    context: ToolContext,
    location_id: Annotated[int, "The unique identifier for the location to retrieve details."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_branch'."]:
    """Get details of a location in the account.

    Retrieves detailed information about a specific location using its unique ID."""
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/branches/{id}".format(id=location_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION")
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def list_sub_departments(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_sub_departments'."]:
    """Retrieve a list of all sub-departments in the account.

    Use this tool to get an overview of all sub-departments within the account. Ideal for managing organizational structure or accessing department-specific information."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/sub_departments",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION")
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def get_sub_department_details(
    context: ToolContext,
    sub_department_id: Annotated[
        int, "The identifier for the sub-department to retrieve details for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_sub_department'."]:
    """Retrieve details of a sub-department by ID.

    Use this tool to get detailed information about a specific sub-department in the account by providing its ID."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/sub_departments/{id}".format(  # noqa: UP032
            id=sub_department_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION")
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def list_departments(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_departments'."]:
    """Retrieve a list of departments from the account.

    Use this tool to get a complete list of departments associated with your Freshteam account. Ideal for obtaining organizational structure details."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/departments",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION")
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def get_department_details(
    context: ToolContext,
    department_identifier: Annotated[
        int, "The unique identifier for the department to retrieve details."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_department'."]:
    """Retrieve details of a specific department by ID.

    Use this tool to obtain information about a specific department in the account by providing the department ID."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/departments/{id}".format(  # noqa: UP032
            id=department_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION")
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def list_job_levels(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_levels'."]:
    """Retrieve the list of job levels.

    Call this tool to get a list of job levels from Freshteam, useful for HR and recruitment tasks."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/levels",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION")
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def get_level_details(
    context: ToolContext,
    level_id: Annotated[
        int, "The unique ID of the level to retrieve details for. It should be an integer."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_level'."]:
    """Get details of a specified level by ID.

    Use this tool to obtain detailed information about a specific level using its unique ID within the Freshteam service."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/levels/{id}".format(id=level_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION")
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def get_role_list(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_roles'."]:
    """Retrieve a list of roles from Freshteam.

    Use this tool to obtain a comprehensive list of roles within the Freshteam system. This tool is typically called when you need to access role-related information."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/roles",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION")
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def get_role_details(
    context: ToolContext,
    role_id: Annotated[int, "Unique identifier for the role to fetch details."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_role'."]:
    """Fetch details of a specific role by its ID.

    Use this tool to retrieve detailed information about a role using its unique ID. It should be called when you need to access specific role attributes and information from the Freshteam platform."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/roles/{id}".format(id=role_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION")
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def list_candidate_sources(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_candidate_sources'."]:
    """Retrieve a list of candidate sources for recruitment.

    Call this tool to get an overview of different candidate sources used for recruitment processes. Useful for HR and recruiting tasks to understand the available sourcing options."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/candidate_sources",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION")
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def create_candidate_source(
    context: ToolContext,
    candidate_source_label: Annotated[
        str, "The name or label for the new candidate source to be created."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'create_candidate_sources'."]:
    """Create a new candidate source in Freshteam.

    Create a new candidate source in Freshteam to manage recruitment channels."""
    request_data = remove_none_values({"label": candidate_source_label})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/candidate_sources",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION"),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def get_source_categories(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_source_categories'."]:
    """Retrieve source categories from Freshteam.

    This tool retrieves a list of source categories from the Freshteam application. It should be called when you need to access or display available candidate source categories."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/candidate_source_categories",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION")
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def list_user_functions(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_user_functions'."]:
    """Retrieve a list of user functions from Freshteam.

    This tool is used to fetch and retrieve a comprehensive list of functions assigned to users within the Freshteam platform. It should be called whenever there's a need to understand or manage user roles and permissions in Freshteam."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/user_functions",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION")
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def get_user_function_details(
    context: ToolContext,
    user_function_id: Annotated[
        int,
        "The unique identifier for the user function. Provide this ID to retrieve specific function details.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_user_function'."]:
    """Retrieve details about a user's function by ID.

    Use this tool to get specific details about a user's function by providing the user ID. Ideal for when you need information on user roles or functions within Freshteam."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/user_functions/{id}".format(  # noqa: UP032
            id=user_function_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION")
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def get_timeoff_types(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_timeoff_types'."]:
    """Retrieve a list of available time off types.

    Use this tool to get a list of all defined time off types within the system. It helps in understanding the different categories of time off available for employees."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/time_off_types",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION")
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def get_timeoff_type_details(
    context: ToolContext,
    timeoff_type_id: Annotated[
        int,
        "The identifier for the specific time-off type to retrieve details for. Use an integer value.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_timeoff_type'."]:
    """Retrieve details of a specific time-off type.

    This tool fetches details about a specific type of time-off by ID, such as vacation or sick leave types, using the Freshteam API. Call this when you need information on a particular time-off category."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/time_off_types/{id}".format(  # noqa: UP032
            id=timeoff_type_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION")
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def list_timeoff_requests(
    context: ToolContext,
    timeoff_statuses: Annotated[
        list[str] | None,
        "A list of status keys to filter time-off requests, such as 'pending', 'approved'.",
    ] = None,
    user_ids: Annotated[
        list[str] | None, "A list of user identifiers (IDs) to filter time-off requests."
    ] = None,
    leave_type_ids: Annotated[
        list[str] | None,
        "Array of leave type identifiers (IDs) to filter time-off requests by specific leave types.",  # noqa: E501
    ] = None,
    user_location_ids: Annotated[
        list[str] | None,
        "An array of location identifiers as strings to filter time-off requests by user location.",
    ] = None,
    timeoff_start_date: Annotated[
        str | None,
        "The start date for the time-off request. Must be used with `end_date`. Format: YYYY-MM-DD.",  # noqa: E501
    ] = None,
    end_date: Annotated[
        str | None,
        "The end date for the time-off request in YYYY-MM-DD format. Must be greater than `start_date`.",  # noqa: E501
    ] = None,
    page_number: Annotated[int | None, "The current page number of results to retrieve."] = None,
    sort_by: Annotated[
        str | None,
        "Specifies the attribute to sort employee time-off requests. Current option: 'start_date'.",
    ] = None,
    sorting_order: Annotated[
        str | None,
        "Specifies the sorting order for the time-off list. Use 'asc' for ascending or 'desc' for descending order.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_timeoffs'."]:
    """Retrieve a list of employee time-off requests from Freshteam.

    This tool fetches a list of time-off requests from Freshteam, allowing users to view pending or approved time-offs for employees."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/time_offs",
        method="GET",
        params=remove_none_values({
            "status": timeoff_statuses,
            "user": user_ids,
            "leave_type": leave_type_ids,
            "location": user_location_ids,
            "start_date": timeoff_start_date,
            "end_date": end_date,
            "page": page_number,
            "sort": sort_by,
            "sort_type": sorting_order,
        }),
        headers=remove_none_values({
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION")
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def apply_leave_request(
    context: ToolContext,
    leave_start_date: Annotated[str, "The start date for the leave request in YYYY-MM-DD format."],
    end_date: Annotated[
        str,
        "The end date for the leave request in YYYY-MM-DD format. It marks the final day of the requested time off.",  # noqa: E501
    ],
    leave_type_id: Annotated[
        int,
        "The ID representing the type of leave requested. It should be an integer that matches a predefined leave type in the system.",  # noqa: E501
    ],
    leave_request_comments: Annotated[
        str,
        "Comments or notes about the leave request. Useful for providing additional information or context.",  # noqa: E501
    ],
    exclude_leave_days: Annotated[
        list[str] | None,
        "An array of specific weekdays to exclude from the time-off request, e.g., ['Monday', 'Wednesday'].",  # noqa: E501
    ] = None,
    emails_to_notify: Annotated[
        list[str] | None,
        "A list of email addresses to notify about the leave request. Each email should be a string.",  # noqa: E501
    ] = None,
    add_to_calendar: Annotated[
        bool | None, "Specify whether to add the leave to the user's calendar. Use true to add."
    ] = None,
    auto_decline_events: Annotated[
        bool | None,
        "Set to true to automatically decline conflicting calendar events during the leave period. Expect a boolean value.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'createTimeOff'."]:
    """Apply leave request for the logged-in user."""
    request_data = remove_none_values({
        "start_date": leave_start_date,
        "end_date": end_date,
        "optional_leave_days": exclude_leave_days,
        "notify_to": emails_to_notify,
        "add_to_calendar": add_to_calendar,
        "auto_decline_events": auto_decline_events,
        "leave_type_id": leave_type_id,
        "comments": leave_request_comments,
    })
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/time_offs",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION"),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def get_timeoff_details(
    context: ToolContext,
    timeoff_request_id: Annotated[
        int, "The unique identifier for the specific time-off request to retrieve details for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_timeoff'."]:
    """Retrieve details of a specific time-off request.

    Use this tool to get detailed information about a specific time-off request by providing the request ID."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/time_offs/{id}".format(  # noqa: UP032
            id=timeoff_request_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION")
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def cancel_timeoff_request(
    context: ToolContext,
    timeoff_request_id: Annotated[
        int, "The identifier for the timeoff request to be canceled. This is an integer value."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'cancel_timeoff'."]:
    """Cancel a scheduled timeoff request.

    Use this tool to cancel an existing timeoff request by providing the request ID. It is useful for altering or retracting scheduled leave."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/time_offs/{id}/cancel".format(  # noqa: UP032
            id=timeoff_request_id
        ),
        method="PUT",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION")
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def approve_timeoff_request(
    context: ToolContext,
    timeoff_request_id: Annotated[
        int, "The identifier for the specific time-off request to approve."
    ],
    approval_comments: Annotated[
        str | None,
        "Optional comments or feedback from the manager regarding the approval of the time-off request.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'approve_timeoff'."]:
    """Approve an employee's time-off request.

    This tool approves a specific employee's time-off request based on the provided request ID. It should be called when a manager or authorized personnel decides to allow the requested leave."""  # noqa: E501
    request_data = remove_none_values({"comments": approval_comments})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/time_offs/{id}/approve".format(  # noqa: UP032
            id=timeoff_request_id
        ),
        method="PUT",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION"),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def reject_timeoff_request(
    context: ToolContext,
    timeoff_request_id: Annotated[
        int, "The unique identifier of the time-off request to be rejected."
    ],
    rejection_comments: Annotated[
        str | None, "Optional comments explaining the reason for rejecting the time-off request."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'reject_timeoff'."]:
    """Reject a time-off request by ID.

    Use this tool to reject a time-off request, providing the necessary ID for identification."""
    request_data = remove_none_values({"comments": rejection_comments})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/time_offs/{id}/reject".format(  # noqa: UP032
            id=timeoff_request_id
        ),
        method="PUT",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION"),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def list_active_employee_fields(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_employee_fields'."]:
    """Retrieve active employee fields from the form.

    Use this tool to obtain a list of all active fields in the employee form, which can then be utilized for form tracking or custom employee data handling."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/employee_fields",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION")
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def create_custom_employee_field(
    context: ToolContext,
    field_label: Annotated[
        str | None, "The name or title for the custom field to be created in the employee form."
    ] = None,
    employee_form_section_name: Annotated[
        str | None,
        "Specifies the section of the employee form where the custom field will be added. Expecting a string value that matches existing section names.",  # noqa: E501
    ] = None,
    field_type: Annotated[
        str | None, "Specifies the type of the custom field. Options are 'text' or 'number'."
    ] = None,
    is_field_required: Annotated[
        bool | None,
        "Indicate if the custom field is mandatory in the employee form. Use true for mandatory and false for optional.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'create_employee_field'."]:
    """Create a custom field in the employee form.

    This tool is used to create a new custom field in the employee form for managing employee data. Use it when you need to add specific information fields that are not predefined in the system."""  # noqa: E501
    request_data = remove_none_values({
        "label": field_label,
        "required": is_field_required,
        "section_name": employee_form_section_name,
        "field_type": field_type,
    })
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/employee_fields",
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION"),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def list_job_openings(
    context: ToolContext,
    job_status_keys: Annotated[
        list[str] | None,
        "List of status keys to filter the job openings. E.g., ['open', 'closed'].",
    ] = None,
    job_title_filter: Annotated[
        str | None, "Specify the job title to filter the job listings."
    ] = None,
    job_type: Annotated[
        str | None, "Specify the type of jobs to query, such as 'full-time', 'part-time', etc."
    ] = None,
    department_ids: Annotated[
        list[int] | None, "Array of department IDs to filter job listings by specific departments."
    ] = None,
    location_ids: Annotated[
        list[int] | None,
        "List of location identifiers (IDs) for querying job openings by specific locations.",
    ] = None,
    include_remote_jobs: Annotated[
        list[bool] | None, "Boolean flag to include or exclude remote job positions from the query."
    ] = None,
    job_city_filters: Annotated[
        list[str] | None, "List of city names to filter job openings by location."
    ] = None,
    country_filters: Annotated[
        list[str] | None, "A list of country identifiers for job locations to filter the query."
    ] = None,
    query_job_location_states: Annotated[
        list[str] | None,
        "A list of states to filter job listings by. Each entry should be a string representing a state.",  # noqa: E501
    ] = None,
    current_page_number: Annotated[
        int | None, "Specifies the current page number in the pagination of job listings."
    ] = None,
    sort_by: Annotated[
        str | None,
        "Specify the field to sort the job listings by. Currently supports sorting by 'title'.",
    ] = None,
    sort_order: Annotated[
        str | None,
        "Specify the order for sorting the results: 'asc' for ascending or 'desc' for descending.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_jobs'."]:
    """Retrieve a list of current job openings.

    This tool is used to fetch and display a list of job openings. It should be called when needing a comprehensive view of available positions."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/job_postings",
        method="GET",
        params=remove_none_values({
            "status": job_status_keys,
            "title": job_title_filter,
            "type": job_type,
            "department": department_ids,
            "location": location_ids,
            "remote": include_remote_jobs,
            "location_city": job_city_filters,
            "location_country": country_filters,
            "location_state": query_job_location_states,
            "page": current_page_number,
            "sort": sort_by,
            "sort_type": sort_order,
        }),
        headers=remove_none_values({
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION")
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def get_job_details(
    context: ToolContext,
    job_identifier: Annotated[int, "Unique identifier for the job to retrieve details."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_job'."]:
    """Retrieve detailed information about a specific job posting.

    Call this tool to get comprehensive details of a job posting using its unique ID."""
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/job_postings/{id}".format(  # noqa: UP032
            id=job_identifier
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION")
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def fetch_applicants_for_job_posting(
    context: ToolContext,
    job_posting_id: Annotated[
        int,
        "The unique identifier for the job posting. Use this to fetch applicants related to a specific job.",  # noqa: E501
    ],
    applicant_status_keys: Annotated[
        list[str] | None, "List of status keys to filter applicants by their current status."
    ] = None,
    applicant_stage_ids: Annotated[
        list[int] | None, "Array of integers representing the identifiers of applicant stages."
    ] = None,
    follower_ids: Annotated[
        list[int] | None, "List of follower IDs to filter applicants by their followers."
    ] = None,
    query_candidate_first_name: Annotated[
        str | None, "Specify the first name of the candidate to filter the applicants."
    ] = None,
    candidate_last_name: Annotated[
        str | None, "Filter applicants by the last name of a candidate to query."
    ] = None,
    candidate_email: Annotated[str | None, "Email address of the candidate to query."] = None,
    candidate_source_ids: Annotated[
        list[int] | None,
        "Array of integers representing the IDs of candidate or job application sources.",
    ] = None,
    candidate_source_categories: Annotated[
        list[int] | None,
        "Identifiers for the source categories of candidates or their job applications as IDs.",
    ] = None,
    candidate_owner_ids: Annotated[
        list[int] | None, "An array of integers representing the candidate owner IDs to query."
    ] = None,
    candidate_city_queries: Annotated[
        list[str] | None, "List of cities to filter applicant search by city name."
    ] = None,
    candidate_country_codes: Annotated[
        list[str] | None, "List of country codes to filter candidates by location."
    ] = None,
    candidate_tags_to_query: Annotated[
        list[str] | None, "A list of tags associated with candidates to filter by."
    ] = None,
    candidate_skills: Annotated[
        list[str] | None, "List of skills to filter the candidates. Each skill should be a string."
    ] = None,
    candidate_companies_to_query: Annotated[
        list[str] | None,
        "List of company names to filter candidates by their past or current positions.",
    ] = None,
    candidate_positions_titles: Annotated[
        list[str] | None, "An array of job titles to filter candidates by their position titles."
    ] = None,
    candidate_rating_filter: Annotated[
        list[str] | None,
        "An array of strings representing the ratings of candidates to filter the applicants list.",
    ] = None,
    candidate_referred_by_ids: Annotated[
        list[int] | None,
        "Array of integer IDs representing the identifiers of individuals who referred the candidate.",  # noqa: E501
    ] = None,
    requisition_identifiers: Annotated[
        list[int] | None, "List of requisition IDs to filter applicants."
    ] = None,
    applicant_creation_date: Annotated[
        str | None, "Date when the applicant was created. Use format YYYY-MM-DD."
    ] = None,
    applicant_created_since: Annotated[
        str | None, "The start date to filter applicants created since, in YYYY-MM-DD format."
    ] = None,
    applicant_updated_since: Annotated[
        str | None, "Filter applicants updated since a specific date. Format: YYYY-MM-DD."
    ] = None,
    applicant_list_page_number: Annotated[
        int | None,
        "The page number to retrieve a specific subset of applicants in paginated results.",
    ] = None,
    sort_by: Annotated[
        str | None, "Field to sort the applicants by, such as first name, last name, rating, etc."
    ] = None,
    sort_type: Annotated[
        str | None,
        "Defines the order in which applicants are sorted, either ascending ('asc') or descending ('desc').",  # noqa: E501
    ] = None,
    filter_candidates_by_email_existence: Annotated[
        bool | None, "Specify true for candidates with an email address; false for those without."
    ] = None,
    filter_by_candidate_response: Annotated[
        bool | None,
        "Filter applicants based on their response status. Use 'true' if the candidate has responded, 'false' otherwise.",  # noqa: E501
    ] = None,
    is_candidate_blocked: Annotated[
        bool | None, "Indicates if the candidate is blocked. Accepts true for blocked candidates."
    ] = None,
    fetch_deleted_applicants: Annotated[
        bool | None, "Set to true to fetch applicants marked as deleted."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_applicants'."]:
    """Retrieve applicants for a specified job posting.

    Use this tool to get all applicants for a particular job posting by providing the job posting ID."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/job_postings/{id}/applicants".format(  # noqa: UP032
            id=job_posting_id
        ),
        method="GET",
        params=remove_none_values({
            "status": applicant_status_keys,
            "stage": applicant_stage_ids,
            "followers_id": follower_ids,
            "candidate_first_name": query_candidate_first_name,
            "candidate_last_name": candidate_last_name,
            "candidate_email": candidate_email,
            "candidate_source": candidate_source_ids,
            "candidate_source_category": candidate_source_categories,
            "candidate_owner": candidate_owner_ids,
            "candidate_city": candidate_city_queries,
            "candidate_country_code": candidate_country_codes,
            "candidate_tags": candidate_tags_to_query,
            "candidate_skills": candidate_skills,
            "candidate_positions_company": candidate_companies_to_query,
            "candidate_positions_title": candidate_positions_titles,
            "candidate_rating": candidate_rating_filter,
            "candidate_referred_by": candidate_referred_by_ids,
            "candidate_has_email": filter_candidates_by_email_existence,
            "candidate_responded": filter_by_candidate_response,
            "candidate_spam": is_candidate_blocked,
            "requisition_id": requisition_identifiers,
            "created_at": applicant_creation_date,
            "created_since": applicant_created_since,
            "updated_since": applicant_updated_since,
            "deleted": fetch_deleted_applicants,
            "page": applicant_list_page_number,
            "sort": sort_by,
            "sort_type": sort_type,
        }),
        headers=remove_none_values({
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION")
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def add_job_applicant(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    job_posting_id: Annotated[
        int | None,
        "The identifier for the job posting to which the applicant is being added. Provide as an integer.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'create_applicant'."]:
    """Submits an applicant for a job posting.

    Use this tool to create a new applicant for a specific job posting by providing the necessary details. This helps in adding candidates to your recruitment pipeline within Freshteam.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS["ADDJOBAPPLICANT_REQUEST_BODY_SCHEMA"],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not job_posting_id:
        missing_params.append(("job_posting_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{{p[0]}} ({{p[1]}})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {{param_names}}",
            developer_message=(f"Required parameters validation failed: {{param_details}}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{{param_details}}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n"
                + json.dumps(REQUEST_BODY_SCHEMAS["ADDJOBAPPLICANT_REQUEST_BODY_SCHEMA"], indent=2)
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n"
                + json.dumps(REQUEST_BODY_SCHEMAS["ADDJOBAPPLICANT_REQUEST_BODY_SCHEMA"], indent=2)
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://adityasharma2519.freshteam.com/api/job_postings/{id}/applicants".format(  # noqa: UP032
            id=job_posting_id
        ),
        method="POST",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["ADDJOBAPPLICANT_REQUEST_BODY_SCHEMA"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION"),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def retrieve_applicant_details(
    context: ToolContext,
    applicant_id: Annotated[int, "The unique identifier of the applicant to retrieve details for."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_applicant'."]:
    """Retrieve detailed information about a specific applicant.

    Use this tool to fetch and return detailed information about a job applicant using their unique ID. Ideal for retrieving candidate profiles during recruitment processes."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/applicants/{id}".format(id=applicant_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION")
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def update_applicant(
    context: ToolContext,
    applicant_id: Annotated[int, "The unique identifier for the applicant to be updated."],
    custom_field_column_name: Annotated[
        str | None, "Specify the column name of the custom field to update for the applicant."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'update_applicant'."]:
    """Update an applicant's details in Freshteam.

    Use this tool to update information about an applicant in the Freshteam system. It should be called when modifications to an applicant's profile are needed."""  # noqa: E501
    request_data = remove_none_values({"custom_fields": {"column_name": custom_field_column_name}})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/applicants/{id}".format(id=applicant_id),  # noqa: UP032
        method="PUT",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION"),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def archive_applicant(
    context: ToolContext,
    applicant_id: Annotated[int, "The unique identifier for the applicant to be archived."],
    applicant_department_ids: Annotated[
        list[int] | None, "List of department IDs to associate with the applicant when archiving."
    ] = None,
    applicant_tags: Annotated[
        list[str] | None,
        "A list of tags to categorize the applicant when archiving. This helps in organizing and retrieving the applicant based on these tags.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'archive_applicant'."]:
    """Archive an applicant in Freshteam.

    Use this tool to archive an applicant within the Freshteam platform. This tool is helpful when you need to update an applicant's status to 'archived' after their evaluation or selection process."""  # noqa: E501
    request_data = remove_none_values({
        "department_ids": applicant_department_ids,
        "tags": applicant_tags,
    })
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/applicants/{id}/archive".format(  # noqa: UP032
            id=applicant_id
        ),
        method="PUT",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION"),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def update_applicant_sub_stage(
    context: ToolContext,
    applicant_id: Annotated[
        int, "The unique identifier for the applicant to update the sub stage."
    ],
    applicant_sub_stage_id: Annotated[
        int | None,
        "The identifier for the new sub stage to move the applicant to. This should be an integer value.",  # noqa: E501
    ] = None,
    decline_reason_identifier: Annotated[
        int | None,
        "The ID representing the reason for declining the applicant. This is required if the applicant is being declined.",  # noqa: E501
    ] = None,
    update_comment: Annotated[
        str | None, "A comment or note about the sub stage change. This should be a string value."
    ] = None,
    applicant_date_of_joining: Annotated[
        str | None,
        "Specify the applicant's date of joining in YYYY-MM-DD format if known. This is relevant for scheduling and process documentation.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'move_sub_stage'."]:
    """Updates the sub stage of an applicant's hiring process.

    This tool should be called to update the sub stage of a specific applicant within the hiring process. Use it when an applicant needs to advance or be moved to a different sub stage."""  # noqa: E501
    request_data = remove_none_values({
        "sub_stage_id": applicant_sub_stage_id,
        "decline_reason_id": decline_reason_identifier,
        "comment": update_comment,
        "date_of_joining": applicant_date_of_joining,
    })
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/applicants/{id}/move_sub_stage".format(  # noqa: UP032
            id=applicant_id
        ),
        method="PUT",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION"),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def list_active_applicant_fields(
    context: ToolContext,
    job_posting_id: Annotated[
        int, "The identifier for the job posting to retrieve active applicant fields."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_applicant_fields'."]:
    """Retrieve active applicant fields in a job posting form.

    Use this tool to get a list of active applicant fields for a specific job posting. It should be called when you need to understand which fields are required or available for applicants."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/job_postings/{id}/applicant_fields".format(  # noqa: UP032
            id=job_posting_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION")
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def list_active_job_fields(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_job_fields'."]:
    """Retrieve a list of active job fields for job postings.

    Use this tool to obtain a current list of active job fields available in the job posting forms. This can be useful for understanding the available fields when creating or managing job postings."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/job_posting_fields",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION")
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def get_candidate_details(
    context: ToolContext,
    candidate_id: Annotated[
        int, "The unique identifier for the candidate whose details you want to retrieve."
    ],
    additional_properties_to_include: Annotated[
        list[str] | None,
        "Specify additional properties to include in the response, such as skills, education, or experience. Provide as an array of strings.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_candidate'."]:
    """Retrieve detailed information about a specific candidate.

    This tool is used to get comprehensive details of a candidate by their ID, including personal and professional information. It should be called when you need to access a candidate's specific information stored in the Freshteam service."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/candidates/{id}".format(id=candidate_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({"include": additional_properties_to_include}),
        headers=remove_none_values({
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION")
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def update_candidate_details(
    context: ToolContext,
    mode: Annotated[
        ToolMode,
        "Operation mode: 'get_request_schema' returns the OpenAPI spec "
        "for the request body, 'execute' performs the actual operation",
    ],
    candidate_id: Annotated[
        int | None,
        "The unique identifier of the candidate to be updated.  Required when mode is 'execute', ignored when mode is 'get_request_schema'.",  # noqa: E501
    ] = None,
    request_body: Annotated[
        str | None,
        "Stringified JSON representing the request body. Required when "
        "mode is 'execute', ignored when mode is 'get_request_schema'",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'update_candidate'."]:
    """Update candidate information in Freshteam.

    Use this tool to update the details of a candidate in Freshteam. It should be called when there is a need to modify existing candidate records.

    Note: Understanding the request schema is necessary to properly create
    the stringified JSON input object for execution.\n\nThis operation also requires path parameters.

    Modes:
    - GET_REQUEST_SCHEMA: Returns the schema. Only call if you don't
      already have it. Do NOT call repeatedly if you already received
      the schema.
    - EXECUTE: Performs the operation with the provided request body
      JSON.\n      Note: You must also provide the required path parameters when executing.

    If you need the schema, call with mode='get_request_schema' ONCE, then execute.
    """  # noqa: E501
    if mode == ToolMode.GET_REQUEST_SCHEMA:
        return {
            "request_body_schema": REQUEST_BODY_SCHEMAS[
                "UPDATECANDIDATEDETAILS_REQUEST_BODY_SCHEMA"
            ],
            "instructions": (
                "Use the request_body_schema to construct a valid JSON object. "
                "Once you have populated the object following the schema "
                "structure and requirements, call this tool again with "
                "mode='execute' and the stringified JSON as the "
                "request_body parameter along with the required path parameters. "
                "Do NOT call the schema mode again - you already have "
                "the schema now."
            ),
        }

    # Mode is EXECUTE - validate parameters
    # Validate required parameters
    missing_params = []
    if not candidate_id:
        missing_params.append(("candidate_id", "path"))

    if missing_params:
        param_names = [p[0] for p in missing_params]
        param_details = ", ".join([f"{{p[0]}} ({{p[1]}})" for p in missing_params])
        raise RetryableToolError(
            message=f"Missing required parameters: {{param_names}}",
            developer_message=(f"Required parameters validation failed: {{param_details}}"),
            additional_prompt_content=(
                f"The following required parameters are missing: "
                f"{{param_details}}. Please call this tool again with all "
                "required parameters."
            ),
        )

    # Validate request body is provided (not None or empty string)
    # Note: Empty objects like {} are allowed - schema validation will check if valid
    if request_body is None or request_body.strip() == "":
        raise RetryableToolError(
            message="Request body is required when mode is 'execute'",
            developer_message="The request_body parameter was null or empty string",
            additional_prompt_content=(
                "The request body is required to perform this operation. "
                "Use the schema below to construct a valid JSON object, "
                "then call this tool again in execute mode with the "
                "stringified JSON as the request_body parameter.\n\n"
                "Schema:\n\n"
                + json.dumps(
                    REQUEST_BODY_SCHEMAS["UPDATECANDIDATEDETAILS_REQUEST_BODY_SCHEMA"], indent=2
                )
            ),
        )

    # Parse JSON
    try:
        request_data = json.loads(request_body)
    except json.JSONDecodeError as e:
        raise RetryableToolError(
            message=f"Invalid JSON in request body: {e!s}",
            developer_message=f"JSON parsing failed: {e!s}",
            additional_prompt_content=(
                f"The request body contains invalid JSON. Error: {e!s}\n\n"
                "Please provide a valid JSON string that matches the schema "
                "below, then call this tool again in execute mode.\n\n"
                "Schema:\n\n"
                + json.dumps(
                    REQUEST_BODY_SCHEMAS["UPDATECANDIDATEDETAILS_REQUEST_BODY_SCHEMA"], indent=2
                )
            ),
        ) from e

    response = await make_request_with_schema_validation(
        url="https://adityasharma2519.freshteam.com/api/candidates/{id}".format(id=candidate_id),  # noqa: UP032
        method="PUT",
        request_data=request_data,
        schema=REQUEST_BODY_SCHEMAS["UPDATECANDIDATEDETAILS_REQUEST_BODY_SCHEMA"],
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION"),
        }),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def add_applicant_comment(
    context: ToolContext,
    applicant_id: Annotated[
        int, "The unique identifier for the applicant to whom the comment will be added."
    ],
    comment_text: Annotated[
        str, "The content of the comment or note to be added to the applicant's profile."
    ],
    recipient_user_ids_for_notifications: Annotated[
        list[int] | None,
        "An array of user IDs to be notified about the comment. Each ID should be an integer.",
    ] = None,
    attachment_urls: Annotated[
        list[str] | None,
        "Array of strings representing URLs of files to attach to the applicant comment.",
    ] = None,
    is_private_comment: Annotated[
        bool | None,
        "Specify if the comment should be private. Use true for private and false for public.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'create_applicant_comment'."]:
    """Add a comment to an applicant's profile.

    Use this tool to add a comment or note to a specific applicant's profile in the Freshteam system. This is useful for recruiters who want to record feedback or additional information about an applicant."""  # noqa: E501
    request_data = remove_none_values({
        "body": comment_text,
        "private": is_private_comment,
        "notify_ids": recipient_user_ids_for_notifications,
        "attachments": attachment_urls,
    })
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/applicants/{id}/comments".format(  # noqa: UP032
            id=applicant_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION"),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def create_applicant_email(
    context: ToolContext,
    applicant_id: Annotated[
        int,
        "The unique identifier for the applicant. Use this ID to specify the recipient of the email.",  # noqa: E501
    ],
    email_body_content: Annotated[
        str,
        "The main content of the email to be sent to the applicant. Should be a string containing the message you want to convey.",  # noqa: E501
    ],
    email_subject: Annotated[str, "The subject of the email to be sent to the applicant."],
    carbon_copy_recipient_ids: Annotated[
        list[int] | None,
        "An array of integer IDs representing additional recipients to be CC'd in the email.",
    ] = None,
    bcc_recipient_ids: Annotated[
        list[int] | None,
        "List of applicant IDs to include as BCC in the email. These IDs should be integers.",
    ] = None,
    make_email_private: Annotated[
        bool | None, "Set to true to mark the email as private, or false to not mark it as private."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'create_applicant_email'."]:
    """Create an email for an applicant.

    Use this tool to create and send an email to a specific applicant using their ID. Ideal for recruitment and communication purposes."""  # noqa: E501
    request_data = remove_none_values({
        "body": email_body_content,
        "private": make_email_private,
        "subject": email_subject,
        "cc_ids": carbon_copy_recipient_ids,
        "bcc_ids": bcc_recipient_ids,
    })
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/applicants/{id}/emails".format(  # noqa: UP032
            id=applicant_id
        ),
        method="POST",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Content-Type": "application/json",
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION"),
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_secrets=["FRESHTEAM_AUTHORIZATION"])
async def get_interview_details(
    context: ToolContext,
    interview_id: Annotated[int, "The unique identifier for the interview to retrieve details."],
    additional_properties_to_include: Annotated[
        list[str] | None,
        "List of additional properties to include in the response, such as schedule or participants.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'get_interview'."]:
    """Retrieve detailed information about a specific interview.

    Use this tool to obtain detailed information regarding a specific interview by providing the interview ID. It is ideal for fetching interview data such as schedule, participants, and notes."""  # noqa: E501
    request_data = remove_none_values({})
    content = json.dumps(request_data) if request_data else None
    response = await make_request(
        url="https://adityasharma2519.freshteam.com/api/interviews/{id}".format(id=interview_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({"include": additional_properties_to_include}),
        headers=remove_none_values({
            "Authorization": context.get_secret("FRESHTEAM_AUTHORIZATION")
        }),
        content=content,
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}

