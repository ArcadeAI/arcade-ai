"""Arcade Starter Tools for Figma

DO NOT EDIT THIS MODULE DIRECTLY.

THIS MODULE WAS AUTO-GENERATED BY TRANSPILING THE API STARTER TOOL JSON DEFINITIONS
IN THE ../wrapper_tools DIRECTORY INTO PYTHON CODE. ANY CHANGES TO THIS MODULE WILL
BE OVERWRITTEN BY THE TRANSPILER.
"""

import asyncio
from typing import Annotated, Any

import httpx
from arcade_tdk import ToolContext, tool
from arcade_tdk.auth import OAuth2

# Retry configuration
INITIAL_RETRY_DELAY = 0.5  # seconds

HTTP_CLIENT = httpx.AsyncClient(
    timeout=httpx.Timeout(60.0, connect=10.0),
    limits=httpx.Limits(max_keepalive_connections=20, max_connections=100),
    transport=httpx.AsyncHTTPTransport(retries=3),
    http2=True,
    follow_redirects=True,
)


def remove_none_values(data: dict[str, Any]) -> dict[str, Any]:
    return {k: v for k, v in data.items() if v is not None}


async def make_request(
    url: str,
    method: str,
    params: dict[str, Any] | None = None,
    headers: dict[str, Any] | None = None,
    data: dict[str, Any] | None = None,
    max_retries: int = 3,
) -> httpx.Response:
    """Make an HTTP request with retry logic for 5xx server errors."""
    for attempt in range(max_retries):
        try:
            response = await HTTP_CLIENT.request(
                url=url,
                method=method,
                params=params,
                headers=headers,
                data=data,
            )
            response.raise_for_status()
        except httpx.HTTPStatusError as e:
            # Only retry on 5xx server errors
            if e.response.status_code >= 500 and attempt < max_retries - 1:
                # Exponential backoff: 0.5s, 1s, 2s
                await asyncio.sleep(INITIAL_RETRY_DELAY * (2**attempt))
                continue
            # Re-raise for 4xx errors or if max retries reached
            raise
        except httpx.RequestError as e:
            # Don't retry request errors (network issues are handled by transport)
            raise
        else:
            return response

    # This should never be reached, but satisfies type checker
    raise httpx.RequestError("Max retries exceeded")  # noqa: TRY003


@tool(requires_auth=OAuth2(id="arcade-figma", scopes=["files:read", "file_content:read"]))
async def retrieve_figma_file(
    context: ToolContext,
    figma_file_key: Annotated[
        str, "Unique key for the Figma file or branch to retrieve JSON data from."
    ],
    specific_version_id: Annotated[
        str | None,
        "Specify a version ID to retrieve a particular version of the Figma file. Leave blank for the current version.",  # noqa: E501
    ] = None,
    node_ids: Annotated[
        str | None,
        "Comma-separated list of node IDs to fetch specific parts of the document. It returns nodes, their children, and paths.",  # noqa: E501
    ] = None,
    document_depth: Annotated[
        float | None,
        "Positive integer representing how deep into the Figma document tree to traverse. For example, setting this to 1 returns only Pages, setting it to 2 returns Pages and all top level objects on each page. Omitting this parameter returns all nodes.",  # noqa: E501
    ] = None,
    export_vector_data: Annotated[
        str | None, 'Set this to "paths" if you want to include vector data in the export.'
    ] = None,
    include_plugin_data: Annotated[
        str | None,
        'Specify plugin IDs or "shared" to include their data in the `pluginData` and `sharedPluginData` fields of the response.',  # noqa: E501
    ] = None,
    include_branch_metadata: Annotated[
        bool | None,
        "Set to true to include branch metadata for the requested file. If the file is a branch, the main file's key will be included. If the file has branches, their metadata will also be included. Defaults to false.",  # noqa: E501
    ] = False,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getFile'."]:
    """Retrieve Figma file document and components by file key.

    This tool fetches the document and component metadata from a specified Figma file using its unique file key. Call this tool to get detailed JSON data about a Figma document and its components."""  # noqa: E501
    response = await make_request(
        url="https://api.figma.com/v1/files/{file_key}".format(file_key=figma_file_key),  # noqa: UP032
        method="GET",
        params=remove_none_values({
            "version": specific_version_id,
            "ids": node_ids,
            "depth": document_depth,
            "geometry": export_vector_data,
            "plugin_data": include_plugin_data,
            "branch_data": include_branch_metadata,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-figma", scopes=["files:read", "file_content:read"]))
async def get_figma_file_nodes(
    context: ToolContext,
    node_ids: Annotated[
        str, "A comma-separated list of node IDs to retrieve and convert from the Figma file."
    ],
    file_key: Annotated[
        str,
        "The key for the Figma file to export JSON data from. It can be a file key or branch key.",
    ],
    version_id: Annotated[
        str | None, "Specify a version ID to retrieve. If omitted, the current version is returned."
    ] = None,
    node_tree_depth: Annotated[
        float | None,
        "Positive integer representing how deep into the node tree to traverse starting from the desired node. Setting this to 1 returns only direct children.",  # noqa: E501
    ] = None,
    export_vector_data: Annotated[
        str | None, 'Set this to "paths" to export vector data from the Figma nodes.'
    ] = None,
    plugins_to_include: Annotated[
        str | None,
        "A comma-separated list of plugin IDs and/or 'shared' to include their data in the result.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getFileNodes'."]:
    """Retrieve nodes from a specified Figma file by IDs.

    Call this tool to get detailed information about specific nodes within a Figma file using the file key and node IDs. The response includes metadata such as name, last modified date, thumbnail URL, editor type, version, and link access permissions. It also provides component and style mappings."""  # noqa: E501
    response = await make_request(
        url="https://api.figma.com/v1/files/{file_key}/nodes".format(file_key=file_key),  # noqa: UP032
        method="GET",
        params=remove_none_values({
            "ids": node_ids,
            "version": version_id,
            "depth": node_tree_depth,
            "geometry": export_vector_data,
            "plugin_data": plugins_to_include,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-figma", scopes=["files:read", "file_content:read"]))
async def render_images_from_figma_file(
    context: ToolContext,
    node_ids_to_render: Annotated[
        str, "A comma-separated list of Figma node IDs that you want to render into images."
    ],
    figma_file_key: Annotated[
        str,
        "File key or branch key to export images from in Figma. Use `GET /v1/files/:key` with `branch_data` to obtain the branch key.",  # noqa: E501
    ],
    file_version_id: Annotated[
        str | None,
        "Specify a version ID to get a particular version of the Figma file. Leave blank to get the current version.",  # noqa: E501
    ] = None,
    image_scaling_factor: Annotated[
        float | None,
        "A number between 0.01 and 4 to specify the scaling factor for the rendered image.",
    ] = None,
    image_output_format: Annotated[
        str | None,
        "Specify the format for the image output. Acceptable formats are: jpg, png, svg, pdf.",
    ] = "png",
    render_text_as_outlines: Annotated[
        bool | None,
        "Set to true to render text as outlines in SVGs, ensuring consistent visual appearance. Set to false to render text as selectable.",  # noqa: E501
    ] = True,
    include_svg_id_attributes: Annotated[
        bool | None,
        "Include ID attributes for all SVG elements, adding the layer name to each element's ID.",
    ] = False,
    include_node_id_in_svg: Annotated[
        bool | None,
        "Whether to include node ID attributes for all SVG elements. Adds the node ID to a `data-node-id` attribute in SVG.",  # noqa: E501
    ] = False,
    simplify_svg_strokes: Annotated[
        bool | None,
        "Set to true to simplify inside/outside strokes in SVGs. Uses stroke attributes instead of `<mask>` if possible.",  # noqa: E501
    ] = True,
    exclude_overlapping_content: Annotated[
        bool | None,
        "Set to true to exclude content that overlaps the node from rendering. False may increase processing time.",  # noqa: E501
    ] = True,
    use_absolute_node_bounds: Annotated[
        bool | None,
        "Set to true to use the full dimensions of the node without cropping, useful for exporting text nodes fully.",  # noqa: E501
    ] = False,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getImages'."]:
    """Render images from a Figma file using node IDs.

    Use this tool to render images from a specific Figma file by providing node IDs. It returns a map linking node IDs to their respective rendered image URLs. The images will expire after 30 days and may include null values if rendering fails."""  # noqa: E501
    response = await make_request(
        url="https://api.figma.com/v1/images/{file_key}".format(file_key=figma_file_key),  # noqa: UP032
        method="GET",
        params=remove_none_values({
            "ids": node_ids_to_render,
            "version": file_version_id,
            "scale": image_scaling_factor,
            "format": image_output_format,
            "svg_outline_text": render_text_as_outlines,
            "svg_include_id": include_svg_id_attributes,
            "svg_include_node_id": include_node_id_in_svg,
            "svg_simplify_stroke": simplify_svg_strokes,
            "contents_only": exclude_overlapping_content,
            "use_absolute_bounds": use_absolute_node_bounds,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-figma", scopes=["files:read", "file_content:read"]))
async def get_image_fill_links(
    context: ToolContext,
    file_key_or_branch_key: Annotated[
        str,
        "The key representing a Figma file or branch to retrieve image URLs from. Obtain from `GET /v1/files/:key` with `branch_data`.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getImageFills'."]:
    """Retrieve download links for images in Figma document fills.

    This tool retrieves URLs for all images present in the image fills of a Figma document. Use this when you need to download images that users have supplied by dragging them into Figma. The URLs provided will expire after up to 14 days."""  # noqa: E501
    response = await make_request(
        url="https://api.figma.com/v1/files/{file_key}/images".format(  # noqa: UP032
            file_key=file_key_or_branch_key
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-figma", scopes=["file_metadata:read", "files:read"]))
async def get_figma_file_metadata(
    context: ToolContext,
    figma_file_key: Annotated[
        str,
        "The unique file or branch key to get metadata for. Use this to specify which Figma file's metadata to retrieve.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getFileMeta'."]:
    """Retrieve metadata for a specific Figma file.

    Call this tool to obtain metadata for a Figma file using its unique file key. Useful for retrieving details such as version, creator, and other metadata related to a Figma file."""  # noqa: E501
    response = await make_request(
        url="https://api.figma.com/v1/files/{file_key}/meta".format(file_key=figma_file_key),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-figma", scopes=["projects:read", "files:read"]))
async def fetch_team_projects(
    context: ToolContext,
    team_id: Annotated[
        str,
        "The ID of the Figma team from which to list projects. This ID is found in the team URL.",
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getTeamProjects'."]:
    """Retrieve all projects for a specified Figma team.

    Use this tool to get a list of all projects within a specified Figma team. It returns projects that are visible to the authenticated user or the owner of the developer token. Ensure you have the team ID, which can be found in the team URL."""  # noqa: E501
    response = await make_request(
        url="https://api.figma.com/v1/teams/{team_id}/projects".format(team_id=team_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-figma", scopes=["projects:read", "files:read"]))
async def fetch_project_files(
    context: ToolContext,
    project_identifier: Annotated[
        str, "The unique ID of the Figma project from which to list files."
    ],
    include_branch_metadata: Annotated[
        bool | None,
        "Include branch metadata in the response for each main file with a branch inside the project. Set to True to enable.",  # noqa: E501
    ] = False,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getProjectFiles'."]:
    """Fetches all files within a given Figma project.

    Use this tool to retrieve a complete list of files contained in a specified Figma project. It should be called when you need to gather information about the files present in a project."""  # noqa: E501
    response = await make_request(
        url="https://api.figma.com/v1/projects/{project_id}/files".format(  # noqa: UP032
            project_id=project_identifier
        ),
        method="GET",
        params=remove_none_values({"branch_data": include_branch_metadata}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-figma", scopes=["files:read", "file_versions:read"]))
async def fetch_file_versions(
    context: ToolContext,
    file_key_identifier: Annotated[
        str,
        "Specify the file or branch key to retrieve version history. Obtain branch keys via `GET /v1/files/:key` with `branch_data`.",  # noqa: E501
    ],
    items_per_page: Annotated[
        float | None, "The number of items to return per page. Defaults to 30 if not specified."
    ] = None,
    version_id_before: Annotated[
        float | None, "A version ID to fetch versions preceding this ID. Used for pagination."
    ] = None,
    get_versions_after_id: Annotated[
        float | None,
        "A version ID to get versions after it for pagination purposes in the version history.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getFileVersions'."]:
    """Fetches the version history of a Figma file.

    Use this tool to obtain the version history of a specific Figma file, which shows the file's progression over time. This is useful for reviewing changes or for rendering specific versions using another endpoint."""  # noqa: E501
    response = await make_request(
        url="https://api.figma.com/v1/files/{file_key}/versions".format(  # noqa: UP032
            file_key=file_key_identifier
        ),
        method="GET",
        params=remove_none_values({
            "page_size": items_per_page,
            "before": version_id_before,
            "after": get_versions_after_id,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-figma", scopes=["files:read", "file_comments:read"]))
async def retrieve_figma_comments(
    context: ToolContext,
    file_identifier: Annotated[
        str,
        "The key or branch key of the Figma file to retrieve comments from. Use `GET /v1/files/:key` with the `branch_data` query param to get the branch key.",  # noqa: E501
    ],
    return_comments_as_markdown: Annotated[
        bool | None,
        "Return comments in markdown format if set to true; otherwise, return in plain text.",
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getComments'."]:
    """Retrieve comments from a Figma file.

    Use this tool to get all comments left on a specified Figma file. It helps in tracking feedback and discussions related to the file."""  # noqa: E501
    response = await make_request(
        url="https://api.figma.com/v1/files/{file_key}/comments".format(file_key=file_identifier),  # noqa: UP032
        method="GET",
        params=remove_none_values({"as_md": return_comments_as_markdown}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-figma", scopes=["file_comments:write"]))
async def delete_figma_comment(
    context: ToolContext,
    file_or_branch_key: Annotated[
        str,
        "The unique key of the file or branch from which to delete the comment. Use `GET /v1/files/:key` with `branch_data` parameter to obtain the branch key.",  # noqa: E501
    ],
    comment_id_to_delete: Annotated[
        str,
        "The ID of the comment you wish to delete. Only the author of the comment can perform this action.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteComment'."]:
    """Delete a specific comment in Figma.

    Use this tool to delete a comment in Figma. Only the comment's author is permitted to delete it. Call this tool when a user requests to remove their comment."""  # noqa: E501
    response = await make_request(
        url="https://api.figma.com/v1/files/{file_key}/comments/{comment_id}".format(  # noqa: UP032
            file_key=file_or_branch_key, comment_id=comment_id_to_delete
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-figma", scopes=["files:read", "file_comments:read"]))
async def get_comment_reactions(
    context: ToolContext,
    file_identifier: Annotated[
        str,
        "File or branch key to retrieve comment reactions from. Use `GET /v1/files/:key` with `branch_data` query to get the branch key.",  # noqa: E501
    ],
    comment_id: Annotated[
        str, "ID of the comment to retrieve reactions from within the Figma file."
    ],
    pagination_cursor: Annotated[
        str | None, "Cursor for pagination, retrieved from the response of the previous call."
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getCommentReactions'."]:
    """Retrieve reactions for a specific comment in Figma.

    Call this tool to get a list of reactions left on a specified comment within a Figma file. Useful for tracking user engagement or feedback on specific comments."""  # noqa: E501
    response = await make_request(
        url="https://api.figma.com/v1/files/{file_key}/comments/{comment_id}/reactions".format(  # noqa: UP032
            file_key=file_identifier, comment_id=comment_id
        ),
        method="GET",
        params=remove_none_values({"cursor": pagination_cursor}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-figma", scopes=["file_comments:write"]))
async def delete_comment_reaction(
    context: ToolContext,
    reaction_emoji: Annotated[
        str,
        "The specific emoji reaction to delete from the comment. Must match the original emoji used.",  # noqa: E501
    ],
    file_key_or_branch_key: Annotated[
        str,
        "Provide the file or branch key to delete the comment reaction from. Use `GET /v1/files/:key` with the `branch_data` query param to obtain the branch key.",  # noqa: E501
    ],
    comment_id: Annotated[
        str,
        "ID of the comment from which the reaction will be deleted. The reaction can only be removed by the person who added it.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteCommentReaction'."]:
    """Delete a specific comment reaction you added.

    Use this tool to delete a reaction you added to a comment. It can only be used by the person who originally made the reaction."""  # noqa: E501
    response = await make_request(
        url="https://api.figma.com/v1/files/{file_key}/comments/{comment_id}/reactions".format(  # noqa: UP032
            file_key=file_key_or_branch_key, comment_id=comment_id
        ),
        method="DELETE",
        params=remove_none_values({"emoji": reaction_emoji}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-figma", scopes=["files:read", "current_user:read"]))
async def get_user_info(
    context: ToolContext,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getMe'."]:
    """Retrieve information for the authenticated Figma user.

    Call this tool to get details about the authenticated user's profile in Figma."""
    response = await make_request(
        url="https://api.figma.com/v1/me",
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-figma", scopes=["files:read", "team_library_content:read"]))
async def retrieve_team_components(
    context: ToolContext,
    team_identifier: Annotated[
        str,
        "The unique identifier for the team from which to list components. Required to specify the team's library.",  # noqa: E501
    ],
    number_of_items_to_return: Annotated[
        float | None,
        "Number of items to return in the paginated response. Defaults to 30. Maximum of 1000.",
    ] = 30,
    retrieve_after_cursor: Annotated[
        float | None,
        "The cursor indicating the ID after which to start retrieving components. This is exclusive with the 'before' parameter.",  # noqa: E501
    ] = None,
    cursor_before_id: Annotated[
        float | None,
        "An integer cursor indicating the id before which to start retrieving components. This is exclusive with `cursor_after_id`.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getTeamComponents'."]:
    """Retrieve a list of published components in a team library.

    Call this tool to obtain a paginated list of components that have been published within a specific team's library on Figma."""  # noqa: E501
    response = await make_request(
        url="https://api.figma.com/v1/teams/{team_id}/components".format(team_id=team_identifier),  # noqa: UP032
        method="GET",
        params=remove_none_values({
            "page_size": number_of_items_to_return,
            "after": retrieve_after_cursor,
            "before": cursor_before_id,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-figma", scopes=["files:read", "library_content:read"]))
async def get_figma_file_components(
    context: ToolContext,
    main_file_key: Annotated[
        str, "The key of the main Figma file to list components from. It must not be a branch key."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getFileComponents'."]:
    """Retrieve a list of published components from a Figma file.

    Use this tool to access all the published components within a specific Figma file library."""
    response = await make_request(
        url="https://api.figma.com/v1/files/{file_key}/components".format(file_key=main_file_key),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-figma", scopes=["files:read", "library_assets:read"]))
async def get_component_metadata(
    context: ToolContext,
    component_key: Annotated[
        str, "The unique identifier of the Figma component to retrieve metadata for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getComponent'."]:
    """Retrieve metadata for a Figma component by key.

    Use this tool to obtain detailed metadata about a specific component in Figma by providing its unique key."""  # noqa: E501
    response = await make_request(
        url="https://api.figma.com/v1/components/{key}".format(key=component_key),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-figma", scopes=["files:read", "team_library_content:read"]))
async def get_team_component_sets(
    context: ToolContext,
    team_id: Annotated[
        str, "The unique identifier for the team whose component sets are to be listed."
    ],
    number_of_items_per_page: Annotated[
        float | None, "Specify the number of component sets to return per page. Default is 30."
    ] = 30,
    start_after_id: Annotated[
        float | None,
        "Cursor to start retrieving component sets after this ID. Used for pagination. Exclusive with start_before_id.",  # noqa: E501
    ] = None,
    start_before_id: Annotated[
        float | None,
        "Cursor indicating the ID before which to start retrieving component sets. Cannot be used with 'after'.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getTeamComponentSets'."]:
    """Retrieve published component sets from a Figma team library.

    Use this tool to obtain a paginated list of component sets that are published within a Figma team's library. Call this tool when you need details about the component sets available to a specific team."""  # noqa: E501
    response = await make_request(
        url="https://api.figma.com/v1/teams/{team_id}/component_sets".format(team_id=team_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({
            "page_size": number_of_items_per_page,
            "after": start_after_id,
            "before": start_before_id,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-figma", scopes=["files:read", "library_content:read"]))
async def get_published_component_sets(
    context: ToolContext,
    figma_file_key: Annotated[
        str, "Main file key to list component sets from. Ensure it's not a branch key."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getFileComponentSets'."]:
    """Retrieve published component sets from a Figma file.

    Use this tool to obtain a list of component sets that have been published within a specific Figma file library."""  # noqa: E501
    response = await make_request(
        url="https://api.figma.com/v1/files/{file_key}/component_sets".format(  # noqa: UP032
            file_key=figma_file_key
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-figma", scopes=["files:read", "library_assets:read"]))
async def get_published_component_metadata(
    context: ToolContext,
    component_set_id: Annotated[
        str, "The unique identifier of the Figma component set to retrieve metadata for."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getComponentSet'."]:
    """Retrieve metadata for a published Figma component set.

    Use this tool to obtain metadata for a published component set by providing its unique key. This is helpful for designers and developers looking to integrate component details from Figma into their workflow."""  # noqa: E501
    response = await make_request(
        url="https://api.figma.com/v1/component_sets/{key}".format(key=component_set_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-figma", scopes=["files:read", "team_library_content:read"]))
async def get_team_styles(
    context: ToolContext,
    team_id: Annotated[str, "The unique identifier of the Figma team from which to list styles."],
    number_of_items: Annotated[
        float | None,
        "The number of items to return in a paginated list of results. Defaults to 30.",
    ] = 30,
    styles_cursor_after: Annotated[
        float | None,
        "Cursor indicating which id after which to start retrieving styles. Used for pagination. Exclusive with styles_cursor_before.",  # noqa: E501
    ] = None,
    start_retrieving_before_cursor: Annotated[
        float | None,
        "Cursor indicating which ID to start retrieving styles before. Cannot be used with 'start_retrieving_after_cursor'.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getTeamStyles'."]:
    """Retrieve a list of published team styles from Figma.

    This tool retrieves a paginated list of styles published within a Figma team library. Use this to access and view styles that have been shared within a specific team."""  # noqa: E501
    response = await make_request(
        url="https://api.figma.com/v1/teams/{team_id}/styles".format(team_id=team_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({
            "page_size": number_of_items,
            "after": styles_cursor_after,
            "before": start_retrieving_before_cursor,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-figma", scopes=["files:read", "library_content:read"]))
async def get_published_file_styles(
    context: ToolContext,
    main_file_key: Annotated[
        str, "Main file key to list styles from in Figma. This should not be a branch key."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getFileStyles'."]:
    """Retrieve published styles from a Figma file.

    This tool fetches a list of published styles within a specified Figma file library, allowing users to access style information for design consistency and reuse."""  # noqa: E501
    response = await make_request(
        url="https://api.figma.com/v1/files/{file_key}/styles".format(file_key=main_file_key),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-figma", scopes=["files:read", "library_assets:read"]))
async def get_figma_style_metadata(
    context: ToolContext,
    style_key: Annotated[str, "The unique identifier of the Figma style to retrieve metadata for."],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getStyle'."]:
    """Retrieve metadata of a Figma style using its key.

    Call this tool to obtain detailed information about a specific style in Figma by providing its unique key."""  # noqa: E501
    response = await make_request(
        url="https://api.figma.com/v1/styles/{key}".format(key=style_key),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-figma", scopes=["webhooks:read"]))
async def get_figma_webhooks(
    context: ToolContext,
    webhook_context: Annotated[
        str | None, "Specifies the context for the webhooks: 'team', 'project', or 'file'."
    ] = None,
    context_identifier: Annotated[
        str | None,
        "The ID of the context to retrieve webhooks for. Cannot be used with plan_identifier.",
    ] = None,
    plan_id: Annotated[
        str | None,
        "The ID of your plan to retrieve all webhooks for accessible contexts. Use if not specifying context or context_id. Enables pagination.",  # noqa: E501
    ] = None,
    pagination_cursor: Annotated[
        str | None,
        "Cursor for pagination when using plan_api_id. Ignored if using context or context_id. Use next_page or prev_page from previous response.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getWebhooks'."]:
    """Retrieve a list of Figma webhooks.

    Use this tool to get a list of webhooks from Figma. It returns webhooks based on the specified context or plan, with pagination support."""  # noqa: E501
    response = await make_request(
        url="https://api.figma.com/v2/webhooks",
        method="GET",
        params=remove_none_values({
            "context": webhook_context,
            "context_id": context_identifier,
            "plan_api_id": plan_id,
            "cursor": pagination_cursor,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-figma", scopes=["files:read", "webhooks:read"]))
async def get_webhook_by_id(
    context: ToolContext,
    webhook_id: Annotated[
        str,
        "ID of the webhook to retrieve. This ID is required to fetch the specific webhook details.",
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getWebhook'."]:
    """Retrieve webhook information by ID.

    Use this tool to get detailed information about a specific webhook using its ID."""
    response = await make_request(
        url="https://api.figma.com/v2/webhooks/{webhook_id}".format(webhook_id=webhook_id),  # noqa: UP032
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-figma", scopes=["webhooks:write"]))
async def delete_figma_webhook(
    context: ToolContext,
    webhook_id_to_delete: Annotated[
        str,
        "The ID of the Figma webhook you wish to delete. Ensure correctness as this action is irreversible.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteWebhook'."]:
    """Delete a specified Figma webhook permanently.

    Use this tool to permanently delete a specific webhook from Figma. Ensure that you intend to remove the webhook as this action cannot be undone."""  # noqa: E501
    response = await make_request(
        url="https://api.figma.com/v2/webhooks/{webhook_id}".format(  # noqa: UP032
            webhook_id=webhook_id_to_delete
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-figma", scopes=["files:read", "webhooks:read"]))
async def retrieve_recent_webhook_requests(
    context: ToolContext,
    webhook_subscription_id: Annotated[
        str, "The ID of the webhook subscription to retrieve events from for the past week."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getWebhookRequests'."]:
    """Retrieve recent webhook requests for debugging.

    Use this tool to obtain all webhook requests sent in the last week, which can aid in debugging issues related to webhooks."""  # noqa: E501
    response = await make_request(
        url="https://api.figma.com/v2/webhooks/{webhook_id}/requests".format(  # noqa: UP032
            webhook_id=webhook_subscription_id
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-figma", scopes=["file_variables:read"]))
async def get_local_variables(
    context: ToolContext,
    file_key_or_branch_key: Annotated[
        str,
        "Specify the file key or branch key to retrieve variables from the Figma file. Use `GET /v1/files/:key` with `branch_data` query param to obtain the branch key if needed.",  # noqa: E501
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getLocalVariables'."]:
    """Retrieve local and remote variables from a Figma file.

    This tool allows you to retrieve local variables created in a Figma file and remote variables used in it, available for Enterprise orgs. It provides details such as variableId and their associated collections."""  # noqa: E501
    response = await make_request(
        url="https://api.figma.com/v1/files/{file_key}/variables/local".format(  # noqa: UP032
            file_key=file_key_or_branch_key
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-figma", scopes=["file_variables:read"]))
async def get_published_figma_variables(
    context: ToolContext,
    main_file_key: Annotated[
        str, "The main file key to fetch published variables from. Branch keys are not supported."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getPublishedVariables'."]:
    """Retrieve published variables from a Figma file.

    Use this tool to access the variables that are published from a specified Figma file. It's available for full members of Enterprise organizations. The response includes specific IDs and omits modes for variable collections."""  # noqa: E501
    response = await make_request(
        url="https://api.figma.com/v1/files/{file_key}/variables/published".format(  # noqa: UP032
            file_key=main_file_key
        ),
        method="GET",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-figma", scopes=["file_dev_resources:read"]))
async def get_file_dev_resources(
    context: ToolContext,
    main_file_key: Annotated[
        str,
        "Specify the main file key to fetch development resources from. This should not be a branch key.",  # noqa: E501
    ],
    specific_node_ids: Annotated[
        str | None,
        "Comma-separated list of node IDs to filter specific dev resources. If not specified, all resources are returned.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getDevResources'."]:
    """Retrieve development resources from a Figma file.

    Call this tool to get the development resources from a specified Figma file using the file key."""  # noqa: E501
    response = await make_request(
        url="https://api.figma.com/v1/files/{file_key}/dev_resources".format(  # noqa: UP032
            file_key=main_file_key
        ),
        method="GET",
        params=remove_none_values({"node_ids": specific_node_ids}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-figma", scopes=["file_dev_resources:write"]))
async def delete_dev_resource(
    context: ToolContext,
    file_key: Annotated[
        str, "The main file key from which to delete the dev resource (not a branch key)."
    ],
    dev_resource_id: Annotated[
        str, "The ID of the development resource to delete from the Figma file."
    ],
) -> Annotated[dict[str, Any], "Response from the API endpoint 'deleteDevResource'."]:
    """Delete a development resource from a Figma file.

    Use this tool to delete a specified development resource from a Figma file, identified by file key and resource ID."""  # noqa: E501
    response = await make_request(
        url="https://api.figma.com/v1/files/{file_key}/dev_resources/{dev_resource_id}".format(  # noqa: UP032
            file_key=file_key, dev_resource_id=dev_resource_id
        ),
        method="DELETE",
        params=remove_none_values({}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-figma", scopes=["library_analytics:read"]))
async def get_library_analytics_component_actions(
    context: ToolContext,
    group_by_dimension: Annotated[
        str, "Dimension to group analytics data by, such as 'component' or 'team'."
    ],
    library_file_key: Annotated[
        str,
        "File key of the library to fetch analytics data for. It identifies the specific library whose data should be retrieved.",  # noqa: E501
    ],
    pagination_cursor: Annotated[
        str | None,
        "Cursor indicating the page of data to fetch, obtained from a previous API call.",
    ] = None,
    earliest_week_date: Annotated[
        str | None,
        "ISO 8601 date string (YYYY-MM-DD) representing the earliest week to include. Dates are adjusted to the start of a week, defaulting to one year prior if not specified.",  # noqa: E501
    ] = None,
    latest_week_end_date: Annotated[
        str | None,
        "ISO 8601 date string (YYYY-MM-DD) representing the latest week to include in the data. Rounds forward to the nearest week's end. Defaults to the latest computed week.",  # noqa: E501
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getLibraryAnalyticsComponentActions'."
]:
    """Retrieve library analytics component actions data.

    Fetches a list of analytics component actions for a specified library, broken down by the requested dimension."""  # noqa: E501
    response = await make_request(
        url="https://api.figma.com/v1/analytics/libraries/{file_key}/component/actions".format(  # noqa: UP032
            file_key=library_file_key
        ),
        method="GET",
        params=remove_none_values({
            "cursor": pagination_cursor,
            "group_by": group_by_dimension,
            "start_date": earliest_week_date,
            "end_date": latest_week_end_date,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-figma", scopes=["library_analytics:read"]))
async def fetch_library_component_usages(
    context: ToolContext,
    group_by_dimension: Annotated[
        str, "The dimension to group analytics data by, either 'component' or 'file'."
    ],
    library_file_key: Annotated[str, "File key of the library whose analytics data is needed."],
    pagination_cursor: Annotated[
        str | None,
        "Cursor for pagination, indicating which page of data to fetch. It should be obtained from a prior API call response.",  # noqa: E501
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getLibraryAnalyticsComponentUsages'."
]:
    """Fetch library component usage analytics.

    This tool retrieves analytics data on library component usage, categorized by the specified dimension. Useful for understanding how components are being used across designs."""  # noqa: E501
    response = await make_request(
        url="https://api.figma.com/v1/analytics/libraries/{file_key}/component/usages".format(  # noqa: UP032
            file_key=library_file_key
        ),
        method="GET",
        params=remove_none_values({"cursor": pagination_cursor, "group_by": group_by_dimension}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-figma", scopes=["library_analytics:read"]))
async def fetch_library_style_actions(
    context: ToolContext,
    group_analytics_by_dimension: Annotated[
        str, "Specifies the dimension to group returned analytics data by. Use 'style' or 'team'."
    ],
    library_file_key: Annotated[
        str, "The unique file key of the library for which to fetch analytics data."
    ],
    pagination_cursor: Annotated[
        str | None,
        "A cursor to indicate the page of data to fetch. Must be obtained from the previous API call.",  # noqa: E501
    ] = None,
    start_date: Annotated[
        str | None,
        "ISO 8601 date string (YYYY-MM-DD) of the earliest week to include. Rounded to the start of the nearest week. Defaults to one year prior if not specified.",  # noqa: E501
    ] = None,
    latest_week_included: Annotated[
        str | None,
        "ISO 8601 date string (YYYY-MM-DD) for the latest week to include, rounded forward to week end. Defaults to latest computed week.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getLibraryAnalyticsStyleActions'."]:
    """Retrieve library style action analytics data.

    Use this tool to get detailed analytics on style actions from a Figma library, broken down by specified dimensions."""  # noqa: E501
    response = await make_request(
        url="https://api.figma.com/v1/analytics/libraries/{file_key}/style/actions".format(  # noqa: UP032
            file_key=library_file_key
        ),
        method="GET",
        params=remove_none_values({
            "cursor": pagination_cursor,
            "group_by": group_analytics_by_dimension,
            "start_date": start_date,
            "end_date": latest_week_included,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-figma", scopes=["library_analytics:read"]))
async def get_library_style_usage(
    context: ToolContext,
    group_analytics_by_dimension: Annotated[
        str,
        "Specifies the dimension to group the returned analytics data by. Valid options are 'style' or 'file'.",  # noqa: E501
    ],
    library_file_key: Annotated[
        str, "The unique file key of the library to retrieve analytics data."
    ],
    data_page_cursor: Annotated[
        str | None,
        "Cursor to specify which page of data to fetch. This should be obtained from a prior API call.",  # noqa: E501
    ] = None,
) -> Annotated[dict[str, Any], "Response from the API endpoint 'getLibraryAnalyticsStyleUsages'."]:
    """Retrieve library style usage analytics data.

    Use this tool to obtain analytics on how styles are used within a specified library, broken down by the requested dimension."""  # noqa: E501
    response = await make_request(
        url="https://api.figma.com/v1/analytics/libraries/{file_key}/style/usages".format(  # noqa: UP032
            file_key=library_file_key
        ),
        method="GET",
        params=remove_none_values({
            "cursor": data_page_cursor,
            "group_by": group_analytics_by_dimension,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-figma", scopes=["library_analytics:read"]))
async def fetch_library_analytics_actions(
    context: ToolContext,
    group_data_by_dimension: Annotated[
        str, "Specify the dimension to group analytics data by. Options are 'variable' or 'team'."
    ],
    library_file_key: Annotated[
        str, "The file key of the library to retrieve analytics data from."
    ],
    page_cursor: Annotated[
        str | None,
        "Cursor for indicating the specific page of data to fetch, obtained from a prior API call.",
    ] = None,
    earliest_week_to_include: Annotated[
        str | None,
        "ISO 8601 date string (YYYY-MM-DD) for the earliest week. Rounded back to the nearest week start. Defaults to one year prior.",  # noqa: E501
    ] = None,
    end_date: Annotated[
        str | None,
        "ISO 8601 date string (YYYY-MM-DD) of the latest week to include. Dates are rounded forward to the nearest end of a week. Defaults to the latest computed week.",  # noqa: E501
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getLibraryAnalyticsVariableActions'."
]:
    """Retrieve library analytics variable actions data by dimension.

    Provides analytics on library variable actions, segmented by specified dimensions, for informed decision-making and analysis."""  # noqa: E501
    response = await make_request(
        url="https://api.figma.com/v1/analytics/libraries/{file_key}/variable/actions".format(  # noqa: UP032
            file_key=library_file_key
        ),
        method="GET",
        params=remove_none_values({
            "cursor": page_cursor,
            "group_by": group_data_by_dimension,
            "start_date": earliest_week_to_include,
            "end_date": end_date,
        }),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}


@tool(requires_auth=OAuth2(id="arcade-figma", scopes=["library_analytics:read"]))
async def get_library_variable_usages(
    context: ToolContext,
    group_by_dimension: Annotated[
        str, "Specify the dimension ('variable' or 'file') to group analytics data by."
    ],
    library_file_key: Annotated[
        str, "The unique file key of the Figma library to fetch analytics data for."
    ],
    data_page_cursor: Annotated[
        str | None,
        "Cursor for the specific page of data to fetch. Obtainable from a previous API call.",
    ] = None,
) -> Annotated[
    dict[str, Any], "Response from the API endpoint 'getLibraryAnalyticsVariableUsages'."
]:
    """Retrieve library analytics variable usage data.

    Use this tool to get detailed analytics on how variables in a Figma library are being used. It breaks down the data by specified dimensions, helping analyze library performance and usage trends."""  # noqa: E501
    response = await make_request(
        url="https://api.figma.com/v1/analytics/libraries/{file_key}/variable/usages".format(  # noqa: UP032
            file_key=library_file_key
        ),
        method="GET",
        params=remove_none_values({"cursor": data_page_cursor, "group_by": group_by_dimension}),
        headers=remove_none_values({
            "Authorization": "Bearer {authorization}".format(  # noqa: UP032
                authorization=context.get_auth_token_or_empty()
            )
        }),
        data=remove_none_values({}),
    )
    try:
        return {"response_json": response.json()}
    except Exception:
        return {"response_text": response.text}
